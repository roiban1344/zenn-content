---
title: "128ビット符号付き整数の最大値は素数 - Rustで任意精度整数演算"
emoji: "🦚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "math"]
published: false
---

## 概要

$2^n-1$ 型の数はメルセンヌ数と呼ばれ、更に素数である場合にメルセンヌ素数という。本記事では、メルセンヌ数に対する高速な素数判定法であるリュカ・レーマーテストを、Rustの任意精度演算用クレート `rug` を利用して実装する。

## 実行環境

|CPU||
|OS||
|メモリ|16GB|

## 符号付き整数型の範囲について

Rustには組み込みの整数型として $8,\,16,\,32,\,64,\,128$ ビット整数^[アーキテクチャ依存の `usize`, `isize` はここでは除外]がそれぞれ符号付き・符号なしで備わっています^[(Integer Types - The Rust Programming Language)[https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types]]。そのうち符号付き整数は、他の多くの言語と同様、[2の補数](https://ja.wikipedia.org/wiki/2%E3%81%AE%E8%A3%9C%E6%95%B0)によって負の数が表現されます。したがって、ビット数 $n = 8, 16, 32, 64, 128$ に対して、表現可能な値の範囲は $-2^{n-1}$ から $2^{n-1}-1$ （両端を含む）に渡ります。

各々の型で表現可能な最大値を実際に見てみましょう。型の定数として値は（128ビットの場合） `i128::MAX`から取ることができます。

:::details 一応コード
```rust
fn main() {
    println!("{} {}", i8::BITS, i8::MAX);
    println!("{} {}", i16::BITS, i16::MAX);
    println!("{} {}", i32::BITS, i32::MAX);
    println!("{} {}", i64::BITS, i64::MAX);
    println!("{} {}", i128::BITS, i128::MAX);
}
```
:::

|$n$|$2^{n-1}-1$|桁数(十進)|
|----:|----|----:|
|$8$ | $127$ |$3$|
|$16$ | $32767=7 \cdot 31 \cdot 151$ |$5$|
|$32$ | $2147483647$ | $10$ |
|$64$ | $9223372036854775807=7^2\cdot 73\cdot 127\cdot 337\cdot 92737\cdot 649657$ | $19$ |
|$128$ | $170141183460469231731687303715884105727$ |$39$|

表には十進法表記を示しました。語呂合わせでも作ってちょっと覚えてみてもいいかもしれない、と思わせるような数字の並びですが、二進法と十六進法では自明です。

$$
\begin{align}
2^n-1 = (\underbrace{111\cdots 1}_{n\,個})_{2}
=(7\underbrace{{\rm f\,f\,f}\cdots{\rm f}}_{m-1\,個})_{16}
\end{align}
$$

ただし、$n=4m$ です。2進法では全ての桁の数が1であり、基数2における[レピュニット数](https://ja.wikipedia.org/wiki/%E3%83%AC%E3%83%94%E3%83%A5%E3%83%8B%E3%83%83%E3%83%88)になっています。

表には素因数分解も示しました。$n=16,\,64$ の等号の右辺が素因数分解です。一方、等号を含まない行、$n=8,\,32,\,128$ ではこれらの値は素数になっています。

つまり、$8,\,32,\,128$ ビット符号付き整数の最大値は素数なのです。

確かめてみましょう。

```rust:naive_factorization/src/main.rs
fn main() {
    let nums = vec![
        i8::MAX as i128,
        i16::MAX as i128,
        i32::MAX as i128,
        i64::MAX as i128,
        i128::MAX,
    ];
    for n in nums {
        for m in 2.. {
            let (q, r) = (n / m, n % m);
            if r == 0 {
                println!("{} is composite", n);
                break;
            }
            if q <= m {
                println!("{} is prime", n);
                break;
            }
        }
    }
}
```

出力（中断）：
```
127 is prime
32767 is composite
2147483647 is prime
9223372036854775807 is composite
```

……終わらない！　当然です。`170141183460469231731687303715884105727 is prime` が出力されるまでには $\sqrt{2^{127}-1} \simeq 2^{63}$ 回のループ、つまり64ビット整数全てに渡るのとほぼ同じ回数のループを回すことになるためです。

ところがこの $2^{127}-1$ という数は、今から遡ること実に145年前、西暦1876年に素数であることが証明されているのです。当然、電子計算機が発明される以前の時代です。

## メルセンヌ数とは

少し歴史の話から。非負整数 $n$ に対して $2^{n}-1$ 型の整数は**メルセンヌ数**（Mersenne number）^[[メルセンヌ数 \- Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%AB%E3%82%BB%E3%83%B3%E3%83%8C%E6%95%B0)]と呼ばれ、記号 $M_n=2^n-1$ で表されます。特に素数のメルセンヌ数は**メルセンヌ素数**（Mersenne prime）といいます。すなわち、$8, 32, 128$ ビット符号付き整数の最大値はそれぞれ $M_{7}, M_{31}, M_{127}$ で表されるメルセンヌ素数です。

「メルセンヌ数」の呼び名は、

$2^n-1$ *が素数となるのは* $n\leq 257$ *の範囲で* $n=2,3,5,7,13,17,19,31,67,127,257$^[[A109461 Mersenne's original list of "Mersenne" exponents.](https://oeis.org/A109461)] *の11個に限られる*

ことを予想した、16世紀フランスのカトリックの司祭・数学者[メルセンヌ（Marin Mersenne）（1588-1648）](https://en.wikipedia.org/wiki/Marin_Mersenne)に由来します。後の時代になって彼のリストには

- 3つの抜け：$n=61, 89, 107$ に対しても $M_n$ は素数
- 2つの誤り：$n=67, 257$ に対して $M_n$ は実際には合成数

があることが示されました^[つまり実際には $n\leq 257$の範囲で $M_n$ が素数となるのは $n=2,3,5,7,13,17,19,31,61,89,107,127$ の12個。]が、彼に敬意を表して今日でもその名が残っています。なお、正しいリストを得る方法は後で見ることになります。

$M_n$ が素数であるためには $n$ が素数であることが必要です。なぜなら、$n$ が合成数であるとき2つの非負整数 $1<a,b<n$ によって $n=ab$ と表され、

$$
\begin{align}
M_n = 2^{ab}-1 = (2^a-1)(2^{a(b-1)}+2^{a(b-2)+\cdots + 2 + 1})
\end{align}
$$

という分解^[$2^{ab}-1$ は $2^a-1$ と $2^b-1$ でともに割り切れますが、その2つの積で割り切れるとは限りません。実際、$2^{2\cdot 4}-1=255$ は $2^2-1=3$ と $2^4-1=15$ で割り切れますが、その積 $3\cdot 15=45$ では割り切れません。$2^n-1$ の「因数分解」による整数の積への分解は、少なくとも[円分多項式](https://ja.wikipedia.org/wiki/%E5%86%86%E5%88%86%E5%A4%9A%E9%A0%85%E5%BC%8F)までは行えます。「円分多項式に2を代入した値」の数列が[A019320](https://oeis.org/A019320)として登録されています。合成数に対する「円分多項式に2を代入した値」が合成数となる最小の例は18番目の57です。]から、$M_n$ は $1 < 2^a-1 < M_n$ を約数に持つためです。

しかし逆は成り立ちません。すなわち、素数 $p$ に対して $M_p$ が素数になるとは限りません。最小の反例が $p=11$ の場合で、$M_{11}=2047=23\cdot 89$ と分解されます。以降、本記事では記号 $M_p$ を「素数 $p$ に対するメルセンヌ数（$M_p$自身が素数とは限らない）」の意味で用いることにします。

$p\leq 19$ では $p=11$ を除いて 全て $M_p$ が素数となるため、一見合成数になる例の方が少ないように思われますが、$p$ が大きくなるほどメルセンヌ素数は疎らになっていきます。

64ビット整数の範囲の $M_p$ を素因数分解してみます。この範囲ならナイーブな実装による $M_p$ の素因数分解も数秒で完了します。

```rust
const PRIMES: [i32; 18] = [
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
];

fn main() {
    for p in PRIMES {
        let m: u64 = (1 << p) - 1;
        {
            let mut m = m;
            let mut factors = vec![];
            for d in 2.. {
                while m % d == 0 {
                    m /= d;
                    factors.push(d);
                }
                if m <= d * d {
                    if m != 1 {
                        factors.push(m);
                    }
                    break;
                }
            }
            factors.sort();
            println!(
                "{:>2} {} {:?}",
                p,
                if factors.len() == 1 { "p" } else { "c" },
                factors
            );
        }
    }
}

```

出力：
```
 2 p [3]
 3 p [7]
 5 p [31]
 7 p [127]
11 c [23, 89]
13 p [8191]
17 p [131071]
19 p [524287]
23 c [47, 178481]
29 c [233, 1103, 2089]
31 p [2147483647]
37 c [223, 616318177]
41 c [13367, 164511353]
43 c [431, 9719, 2099863]
47 c [2351, 4513, 13264529]
53 c [6361, 69431, 20394401]
59 c [179951, 3203431780337]
61 p [2305843009213693951]
```
出力の各行は
- 1列目: $p$ の値
- 2列目: `P` なら $M_p$ は素数、`C` なら合成数
- 3列目: 素因数たち（昇順）

を表します。この範囲で既に $p=37, 41, 43, 47, 53, 59$ の連続する6つに対して $M_p$ が合成数になっています。

:::details メルセンヌ数の素因数と素数の無限性について
$M_p$ の素因数を見ると、素因数として「小さい」素数 ($3, 7, 13, \cdots$ 等）がほとんど現れないことに気付きます。実際、$M_p$ の素因数は ($p$ の倍数) $+ 1$ の形に限られる（したがって $p+1$ より大きい）ことが以下のように示されます：

$M_p$ の最小の素因数を $q$ とすると、$2^p \equiv 1 \mod q$。これは $\mathbb{Z}/q\mathbb{Z}$ の乗法群 $(\mathbb{Z}/q\mathbb{Z})^*=\mathbb{Z}/q\mathbb{Z}-\{0\}$ において $2$ の位数が $p$ であることを意味する。したがって $p$ は $(\mathbb{Z}/q\mathbb{Z})^*$ の位数 $q-1$ を割り切り、正整数 $k$ によって $q=kp+1$ と表される。$\square$

特に $p$ が奇素数の場合は ありうる最小の素因数は $2p+1$ で、$M_{11}=2047,\, M_{23}=8388607$ がそれぞれ実際に $2\cdot 11+1=23, 2\cdot23+1=47$ を素因数に持ちます。

特筆すべきことに、この事実は素数が無限に存在することの証明にもなります。最大の素数 $p$ が存在するとすれば、$M_p$ が $p+1$ 以上の素因数を持って矛盾するためです！

参考文献：『天書の証明』
:::

## メルセンヌ数と完全数

メルセンヌ素数は**完全数**^[[完全数 \- Wikipedia](https://ja.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E6%95%B0)。[A000396](https://oeis.org/A000396)] との密接な繋がりから関心が向けられてきました。少々脇道にそれますが簡単に書いておきます。

完全数とは、自身を除く約数の和が自身と一致する非負整数のことです。小さいほうから $1,2,3$ 番目の完全数の実例はそれぞれ $n=6,28,496$ で、

$$
\begin{align}
    6&=1+2+3,\\
    28&=1+2+4+7+14,\\
    496&=1+2+4+8+16+31+62+124+248
\end{align}
$$

と、確かに $n=(n$ 自身を除く $n$ の約数の和)となっています。実は、$M_p$ が素数なら $2^{p-1}M_p$ は完全数であり、逆に**偶数の**完全数はこの形に限られることが知られています。

:::details 証明
(1) $M_p$ が素数なら $n=2^{p-1}M_p$ は完全数であることの証明：

非負整数 $m$ に対して $\sigma$ を $m$ の約数の和とする。これを[約数関数](https://ja.wikipedia.org/wiki/%E7%B4%84%E6%95%B0%E9%96%A2%E6%95%B0)という。$\sigma(m)=2m$ なら $m$ は 完全数である。仮定から $M_p$ は3以上の素数だから、約数関数の性質から、

$$
\sigma(n) = \frac{2^{p}-1}{2-1}\frac{M_p^2-1}{M_p-1} = M_p\cdot 2^p = 2n.
$$

したがって $n$ は完全数。$\square$

(2) $n$ が偶数の完全数なら メルセンヌ素数 $M_p$ が存在して $n=2^{p-1}M_p$ が成り立つことの証明：

$n$ は偶数だから、非負整数 $a$ と 正の奇数 $b$ によって $n=2^a b$ と（一意に）表される。約数関数の性質から、

$$
\sigma(n) = \sigma(2^a)\sigma(b) = (2^{a+1}-1)\sigma(b)
$$

一方、$n$ が完全数であることから、$\sigma(n)=2n=2^{a+1}b$。2つの式を合わせて、

$$
\sigma(b) = b + \frac{b}{2^{a+1}-1}.
$$

左辺は整数だから、右辺第2項 $b/(2^{a+1}-1)=c$ も整数でなくてはならない。したがって分母の $2^{a+1}-1=d$ は $b$ の約数。さらに $a\geq 1$ だから、 $d>1$ と $c<b$ が成り立つ。$\sigma(b)=b+c$ は 「『$b$ の約数の和』は『 $b$ 自身と $b$ より小さい $b$ の約数 $c$ の和』に等しい」ことを意味する。
よって $b$ は $b$ 自身 と $c$ のふたつの約数しか持たないため素数であり、$c=1$。さらに、$b=2^{a+1}-1$ が素数であるためには $a+1$ は素数でなくてはならず（既述）、これを $p$ とおくと $n=2^{p-1}M_p$ と表される。$\square$

オイラーに帰せられる(2)の証明は実に見事です。

参考文献：

:::

この事実により、古代ギリシャから知られていた偶数完全数の探索はメルセンヌ数探索と表裏一体になりました。一方、奇数の完全数は未だ一つも知られていないうえ存在しないとも証明されておらず、数論における有名な未解決問題になっています。

## リュカテスト

本題に入ります。1876年、[リュカ（Édouard Lucas）](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%89%E3%82%A5%E3%82%A2%E3%83%BC%E3%83%AB%E3%83%BB%E3%83%AA%E3%83%A5%E3%82%AB)は以下の判定法を利用し、$M_{127}=2^{127}-1$ が素数であることを示しました。

*$p$ を $4n+3$ 型の素数とする。$R_1=3,\, R_i=R_{i-1}^2-2\,(i\geq 2)$ で再帰的に定まる整数列 $R_i$ について、$R_{p-1}\equiv 0 \mod M_p$ なら $M_p$ は素数、そうでなければ合成数。*

:::details 証明
### 補題(1) 

フィボナッチ数列を 

$$
F_0=F_1=1,\,F_{i}=F_{i-1}+F_{i-2}
$$

リュカ数列を 

$$
L_0=2,\, L_1=1,\, L_{i}=L_{i-1}+L_{i-2}
$$

によってそれぞれ再帰的に定義する。なお、$L_{i}=F_{i+1}+F_{i-1}$。このとき、

$$
\alpha = \frac{1+\sqrt{5}}{2},\,
\beta = \frac{1-\sqrt{5}}{2}
$$

とおくと、

$$
F_i = \frac{\alpha^i-\beta^i}{\sqrt{5}},\,
L_i = \alpha^i + \beta^i.
$$

証明：帰納法による。

### 補題(2)

$$
R_{i} = \alpha^{2^i} + \beta^{2^i} = L_{2^i}\,(i\geq 1). 
$$

証明：帰納法。

### 補題(3)
$q\equiv 1\mod 5$ であるような素数 $q$ について、$F_{q-1} \equiv 0 \mod q$.

$q\equiv 2\mod 5$ であるような素数 $q$ について、$F_{q+1} \equiv 0,\, L_{q+1} \equiv -2\mod q$.


証明：

$$
\begin{align}
    F_{q} &= \frac{1}{2^q\sqrt{5}}\sum_{k=0}^q \binom{q}{k} (\sqrt{5})^k - (-\sqrt{5})^k\\
    &=\frac{1}{2^q\sqrt{5}}\sum_{kは奇数,\, 1\leq k \leq q} \binom{q}{k} 2\cdots 5^{\frac{k-1}{2}},\\
    \therefore 2^{q-1} F_{q} &= \sum_{kは奇数,\, 1\leq k \leq q} \binom{q}{k} \, 5^{\frac{k-1}{2}}
\end{align}
$$

$\mod q$ を取ると、$1\leq k\leq q-1$ で $\binom{q}{k}\equiv 0\mod q$ であることと $2^{q-1}\equiv 1 \mod q$（$\because$ フェルマーの小定理）から和は $k=q$ の項のみが残って、法 $5$ の平方剰余に関するオイラーの規準より、

$$
F_{q} \equiv 5^{\frac{q-1}{2}} \equiv \left(\frac{q}{5}\right) \equiv 
\left\{\begin{array}{cc}
1 & {\rm if}\, q\equiv \pm 1 \mod 5\\
-1 & {\rm if}\, q\equiv \pm 2 \mod 5
\end{array}\right. \mod q.
$$

ほぼ同様にして

$$
\begin{align}
    F_{q+1}  \equiv 
    \left\{\begin{array}{cc}
    1 & {\rm if}\, q\equiv \pm 1 \mod 5\\
    0 & {\rm if}\, q\equiv \pm 2 \mod 5
    \end{array}\right. \mod q.
\end{align}
$$

が分かり、組み合わせると

$$
\begin{align}
    F_{q-1} = F_{q+1}-F_{q}  &\equiv 
    \left\{\begin{array}{cc}
    0 & {\rm if}\, q\equiv \pm 1 \mod 5\\
    1 & {\rm if}\, q\equiv \pm 2 \mod 5
    \end{array}\right. \mod q, \\
    L_{q+1} = 2F_{q} + F_{q+1} &\equiv 
    \left\{\begin{array}{cc}
    3 & {\rm if}\, q\equiv \pm 1 \mod 5\\
    -2 & {\rm if}\, q\equiv \pm 2 \mod 5
    \end{array}\right. \mod q.
\end{align}
$$

を得る。$\square$

### 補題(4)

奇素数 $q$ に対して $F_{i}\equiv 0 \mod q$ となる最小の正整数 $i$ が存在して $e$ であるとする。 正整数 $j$ が $F_{j} \equiv 0 \mod q$ を満たすなら、$e$ は $j$ を割り切る。

証明：
まず、定義から

$$
\begin{align}
    \begin{pmatrix}
    F_{i} & F_{i-1}\\
    F_{i-1} & F_{i-2}
    \end{pmatrix}
    =
    {\bm A}
    \begin{pmatrix}
    F_{i-1} & F_{i-2}\\
    F_{i-2} & F_{i-3}
    \end{pmatrix},\,
    {\bm A}
    :=
    \begin{pmatrix}
    1 & 1\\
    1 & 0
    \end{pmatrix}
\end{align}
$$

が成り立つ。この関係式を繰り返し適用して、

$$
\begin{align}
    \begin{pmatrix}
    F_{i+1} & F_{i}\\
    F_{i} & F_{i-1}
    \end{pmatrix}
    = {\bm A}^{i}
\end{align}
$$

を得る。

$F_{j}\equiv 0 \mod q$ を満たす正整数 $j$ が $e$ で割り切れないと仮定して矛盾を導く。仮定から、整数 $k$ と $1\leq r\leq e-1$ を満たす整数 $r$ が存在して $j=ke+r$ が成り立つ。この $j$ に対して、

$$
\begin{align}
    \begin{pmatrix}
    F_{j+1} & F_{j}\\
    F_{j} & F_{j-1}
    \end{pmatrix}
    &={\bm A}^{ke+r}\\
    &=\left(({\bm A}^e)\right)^k {\bm A}^r\\
    &= 
    \begin{pmatrix}
        F_{e+1} & F_{e}\\
        F_{e} & F_{e-1}
    \end{pmatrix}^k
    \begin{pmatrix}
        F_{r+1} & F_{r}\\
        F_{r} & F_{r-1}
    \end{pmatrix}.
\end{align}
$$

$\mod q$ を取ると、

$$
\begin{gather}
    \begin{pmatrix}
    F_{j-1} & 0\\
    0 & F_{j-1}
    \end{pmatrix}
    \equiv
    \begin{pmatrix}
        F_{e-1} & 0\\
        0 & F_{e-1}
    \end{pmatrix}^k
    \begin{pmatrix}
        F_{r+1} & F_{r}\\
        F_{r} & F_{r-1}
    \end{pmatrix}\mod q\\
    \therefore
    \begin{pmatrix}
    F_{r+1} & F_{r}\\
    F_{r} & F_{r-1}
    \end{pmatrix}
    \equiv
    F_{e-1}^{-k}F_{j}
    \begin{pmatrix}
    1 & 0\\
    0 & 1
    \end{pmatrix}
    \mod q.
\end{gather}
$$

（$F_{e-1}\neq 0$ だから積の逆元が存在）$F_{r}\equiv 0 \mod q$ が成り立つことになり、$e$ の最小性に反する。$\square$

準備ができたので以下本証明に入ります。

(A) $M_p$ が素数なら $R_{p-1} \equiv 0 \mod M_p$ であること 

$p=4n+3$ と表せることから、

$$
M_p=2^{4n+3}-1=8\cdot 16^n-1\equiv 2 \mod 5.
$$　

補題(3)から、$L_{M_p+1} = L_{2^p} = R_{p} \equiv -2 \mod M_p$. 一般に奇素数 $q$ に対して、$R_{k}\equiv -2 \mod q$ となる $k$ が存在するなら、その前後で

$$
\begin{align}
R_{k-1} &  \equiv 0 \mod q,\\ 
R_{k} &= R_{k-1}^2-2\equiv -2 \mod q,\\
R_{k+1} &= R_{k}^2-2 \equiv 2 \mod q,\\
R_{k+2} &= R_{k+1}^2-2 \equiv 2 \mod q,\\
&\vdots
\end{align}
$$

となるため $R_{k-1}$ のみ唯一 $q$ で割り切れる。この奇素数 $q$ を $M_p$ とみなすと $R_{p-1}$ が $M_p$ で割り切れて、しかも他の $R_i$ は $M_p$ では割り切れないことが分かる。

(B) $R_{p-1} \equiv 0 \mod M_p$ なら $M_p$ は素数であること

$M_p$ の素因数の1つをとって $q$ とする。$q$ は $2,5$ のどちらでもない。このとき $R_{p-1} \equiv 0 \mod q$ だが、(A)で行った観察から、$R_{k} \equiv 0 \mod q$ を満たす唯一の $k$ が $k=p-1$ になる。

$$
\begin{align}
F_{2^{k}} &= F_{2^{k-1}}L_{2^{k-1}} & (\because 補題(1)を利用)\\
&=F_1L_1L_2L_4\cdots L_{2^{k-1}}\\
&=R_{1}R_{2}\cdots R_{k-1}
\end{align}
$$

に $k=p$ を代入すると仮定から $F_{2^p} \equiv 0 \mod q$ であり、 補題(4)から、$F_{e} \equiv 0 \mod q$ を満たす最小の $e$ は $2^p$ の約数。ところが上述の理由から $e=2^p$.

補題(3)から $F_{q+1}\equiv 0$ または $F_{q-1}\equiv 0$ であり、再び補題(4)から、$q+1$ か $q-1$ のどちらか一方は $2^p$ で割り切れる。ところが $q$ は $M_p$ の約数だから、$q \leq M_p = 2^p -1$ であり、$q+1=2^p$ しかありえない。すなわち $M_p$ の素因数は $q=2^p-1=M_p$ 自身に限られ、$M_p$ は素数である。$\square$

:::

証明は本質的なところでフィボナッチ数が関わり、しかも全く自明でない結果が導かれる驚嘆すべきものです。

$M_{127}$ より遥かに大きな数千ビットの素数はRSA暗号などのキーとして日常的に用いられていますが、そこで生成されるランダムな整数の素数性の判定には、確率的なアルゴリズムが採用されます。[ミラー・ラビンテスト](https://ja.wikipedia.org/wiki/%E3%83%9F%E3%83%A9%E3%83%BC%E2%80%93%E3%83%A9%E3%83%93%E3%83%B3%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A%E6%B3%95)は実用的な確率的素数判定法の1つです。ここでいう「確率」は「ハッシュ値の衝突確率は現実的には無視できる」という文脈における確率と似ていて、「実際には合成数であるのに素数であると間違って判定してしまう（擬素数）」確率は十分無視できる精度まで任意に小さくすることができます。

確率的な素数判定法が実用に耐えるのは、判定対象の整数の **対数に関する** 多項式時間のアルゴリズムであるからです。一方、例えば試し割りによる方法だと、判定対象の整数**それ自体に関する**多項式時間です。

計算量の観点から見たリュカテストの著しい性質は、決定的であるにもかかわらず確率的な素数判定法よりも高速であるという点にあります。「確率的に素数であるか当てを付けてからリュカテストで決定する」という方法は役に立ちません^[このことに関しては強く確信していますが、実装により逆転が起きうるかどうか知りません。ご存知の方がいれば是非ご教授ください。]。

この強力な判定法を得たリュカは、$M_{127}$ が素数であることを手計算により示しました。その後電子計算が登場して次に小さな $M_{521}$ が（後述のリュカ・レーマーテストにより）素数であることが示されるまでの約75年間^[$M_{127}$ より小さな $M_{61}, M_{89}, M_{107}$ が素数であることが示されたのはその間の期間です。[Table of Known Mersenne Primes](https://primes.utm.edu/mersenne/index.html)]、$M_{127}$ は人類に知られた最大の素数でした。

とはいえ実際に手計算してみようとすると分かりますが、$M_{19}$ くらいでも相当骨が折れる計算になります。歴史に名を遺すとはどういうことかよく分かります。

## 任意精度整数演算

リュカテストを実装します。$R_{i}$ はおよそ前の項の2倍の桁数を取り急速に増加しますが、$M_p$ で剰余を取ればよいので桁数は有限に留まります。それでも、$M_{127}$ の場合には `i128` で扱うと2乗を取る過程でオーバーフローが起こります。

そこで任意桁数の整数演算を導入します。これを実現するRustのクレートとそれぞれの特徴を以下に挙げます^[[num-bigint](https://crates.io/crates/num-bigint)の"Alternatives"の項の表より。また、やや古いが[Redditの投稿](https://www.reddit.com/r/rust/comments/77x3m8/comment/dopcf27/?utm_source=share&utm_medium=web2x&context=3)。]

- [num\-bigint](https://crates.io/crates/num-bigint): 純Rust製、使いやすい
- [rug](https://crates.io/crates/rug): [GMP](https://gmplib.org/)ライブラリのバンドル
- [rust\-gmp](https://crates.io/crates/rust-gmp): 同上（のようだがあまりドキュメントが充実しておらず詳細不明）
- [ramp](https://crates.io/crates/ramp): Nightlyビルド限定
- [apint](https://crates.io/crates/apint): 純Rust製、未完

今回はこの中から `rug` を採用することにしました。



<!-- 計算量に関して -->

<!-- TODO: 揃え位置? -->

<!-- M_pは素数指数に対するメルセンヌ数の意味で用いる -->

