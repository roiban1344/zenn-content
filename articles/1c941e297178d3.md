---
title: "Rustã§MD5ã‚’å®Ÿè£…ï¼ˆã¤ã„ã§ã«sin64ã‚’è¨ˆç®—ï¼‰"
emoji: "ğŸ¶"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "math"]
published: false
---

# æ¦‚è¦

MD5ãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’RFC1321ã«è¨˜è¼‰ã•ã‚ŒãŸä»•æ§˜ã«å¾“ã£ã¦Rustã§å®Ÿè£…ã—ã¾ã™ã€‚ä»˜éŒ²ã¨ã—ã¦ã€ãã®ä¸­ã§åˆ©ç”¨ã•ã‚Œã‚‹ $4294967296|\sin i|$ ã®æ•´æ•°éƒ¨åˆ†ã¨ã„ã†å€¤ã®è¨ˆç®—æ–¹æ³•ã‚‚ç¤ºã—ã¾ã™ã€‚

# èƒŒæ™¯

ã—ã°ã‚‰ãå‰ã‹ã‚‰ä¸»ã«[å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://doc.rust-lang.org/book/title-page.html)ã§Rustã‚’å­¦ã³å§‹ã‚ã¾ã—ãŸã€‚Zennã®ä»¥ä¸‹ã®è¨˜äº‹ã«ã‚‚ãŠä¸–è©±ã«ãªã£ã¦ã„ã¾ã™ã€‚

- [RustCoder â€•â€• AtCoder ã¨ Rust ã§å§‹ã‚ã‚‹ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°å…¥é–€](https://zenn.dev/toga/books/rust-atcoder)
- [Rustå…¥é–€](https://zenn.dev/mebiusbox/books/22d4c1ed9b0003)

å­¦ã¶ã†ã¡ã«ã¡ã‚‡ã£ã¨ã—ãŸã‚µã‚¤ã‚ºã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã¦ã¿ãŸããªã‚Šã€ä»Šæ˜¥æ”¾é€ã•ã‚ŒãŸã‚´ã‚¸ãƒ©SP^[[å®Œå…¨æ–°ä½œTVã‚¢ãƒ‹ãƒ¡ã‚·ãƒªãƒ¼ã‚ºã€Œã‚´ã‚¸ãƒ© ã‚·ãƒ³ã‚®ãƒ¥ãƒ©ãƒã‚¤ãƒ³ãƒˆ Godzilla Singular Pointã€å…¬å¼ã‚µã‚¤ãƒˆ](https://godzilla-sp.jp/)ã€‚ç‰¹ã«ç¬¬4ãƒ»10è©±ã€‚è©¦è¡ŒéŒ¯èª¤ã§ã¯æ±ºã—ã¦åˆæˆæ–¹æ³•ã‚’ç™ºè¦‹ã§ããªã„ç‰©è³ªã€Œã‚¢ãƒ¼ã‚­ã‚¿ã‚¤ãƒ—ã€ã®å–©ãˆã¨ã—ã¦åˆã‚ã¦ç™»å ´ã€‚]ã§é‡è¦ãªå½¹å‰²ã‚’æœãŸã—ãŸ**MD5ãƒãƒƒã‚·ãƒ¥**ã®å®Ÿè£…ã‚’è©¦ã—ã¦ã¿ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

# MD5ã¨ã¯

MD5ã¯ä»»æ„é•·ã®ãƒ“ãƒƒãƒˆåˆ—ã‚’128ãƒ“ãƒƒãƒˆã¨ã„ã†å›ºå®šé•·ã®ãƒãƒƒã‚·ãƒ¥å€¤ã«å¤‰æ›ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã™ã€‚ã—ãŸãŒã£ã¦ç†æƒ³ã¨ã—ã¦ã¯ä»»æ„é•·ã®ãƒ“ãƒƒãƒˆåˆ—ã‚’å¼•æ•°ã«å–ã‚‹ã¹ãã§ã™ãŒã€æœ¬è¨˜äº‹ã§ã¯**æ–‡å­—åˆ—ã«å¯¾ã™ã‚‹**MD5ãƒãƒƒã‚·ãƒ¥é–¢æ•°ã‚’Rustã§å®Ÿè£…ã—ã¾ã™ã€‚

[MD5 \- Wikipedia](https://ja.wikipedia.org/wiki/MD5)

è€ƒæ¡ˆè€…ã¯[Ron Rivest](https://en.wikipedia.org/wiki/Ron_Rivest)^[[RSAæš—å·](https://ja.wikipedia.org/wiki/RSA%E6%9A%97%E5%8F%B7)ã®Rã®æš—å·å­¦è€…ã€‚]ã€‚å½“æ™‚æ—¢ã«è„†å¼±æ€§ã®ç™ºè¦‹ã•ã‚Œã¦ã„ãŸ[MD4](https://ja.wikipedia.org/wiki/MD4)ã®å¾Œç¶™ã¨ã—ã¦1991å¹´ã«è¨­è¨ˆã•ã‚Œã€ç¿Œ1992å¹´ã«ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ä»•æ§˜ãŒ[RFC](https://ja.wikipedia.org/wiki/Request_for_Comments)1321ã¨ã—ã¦å…¬é–‹ã•ã‚Œã¾ã—ãŸã€‚ã“ã®æ–‡æ›¸ã®ä»˜éŒ²ã«ã¯Cè¨€èªã«ã‚ˆã‚‹å®Ÿè£…ãŒä¾‹ç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚

[RFC1321ï¼ˆæ­£èª¤è¡¨ä»˜ãï¼‰](https://www.rfc-editor.org/rfc/inline-errata/rfc1321.html)

ä¸»ã«ã“ã®ä»•æ§˜æ›¸ã«æ²¿ã£ã¦å®Ÿè£…ã‚’é€²ã‚ã¾ã™ã€‚æ‰‹æœ¬ã¨ã—ã¦ä»¥ä¸‹ã®ãƒˆãƒ¬ã‚¤ãƒˆã‚„å®Ÿè£…ä¾‹ã‚‚æŒ™ã’ã¾ã™ã€‚å®Ÿéš›ã«åˆ©ç”¨ã™ã‚‹å ´åˆã«ã¯ã‚ˆãæ•´å‚™ã•ã‚ŒãŸã“ã‚Œã‚‰ã®ãƒˆãƒ¬ã‚¤ãƒˆã®ã„ãšã‚Œã‹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¹ãã§ã—ã‚‡ã†ã€‚

- [md5 \- crates\.io: Rust Package Registry](https://crates.io/crates/md5)
- [md\-5 \- crates\.io: Rust Package Registry](https://crates.io/crates/md-5)
- [MD5/Implementation \- Rosetta Code](https://rosettacode.org/wiki/MD5/Implementation#Rust)

MD5ãƒãƒƒã‚·ãƒ¥åŒ–ã¯[`md5sum`ã‚³ãƒãƒ³ãƒ‰](https://en.wikipedia.org/wiki/Md5sum)ã§ã‚‚æ‰‹è»½ã«è¡Œãˆã¾ã™ã€‚

æœ¬è¨˜äº‹ã§ç›®æ¨™ã¨ã™ã‚‹ã¨ã“ã‚ã®æ–‡å­—åˆ—ã«å¯¾ã™ã‚‹MD5ãƒãƒƒã‚·ãƒ¥ã¯ãŸã¨ãˆã°ã€

```
$ printf '%s' "Rust" | md5sum
f5e265d607cb720058fc166e00083fe8 *-
```

ã®ã‚ˆã†ã«ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰è©¦ã™ã“ã¨ãŒã§ãã¾ã™^[[command line \- How to get the MD5 hash of a string directly in the terminal? \- Ask Ubuntu](https://askubuntu.com/questions/53846/how-to-get-the-md5-hash-of-a-string-directly-in-the-terminal)]ã€‚

ã“ã®çµæœã¯æ–‡å­—åˆ—`Rust`ã«å¯¾ã™ã‚‹MD5ãƒãƒƒã‚·ãƒ¥ãŒ`f5e265d607cb720058fc166e00083fe8`ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ãƒãƒƒã‚·ãƒ¥å€¤ã¯16é€²ã§32æ¡ã€ã™ãªã‚ã¡128ãƒ“ãƒƒãƒˆã§ã‚ã‚‹ã“ã¨ãŒç¢ºã‹ã‚ã‚‰ã‚Œã¾ã™ã€‚

# ãƒã‚¤ãƒˆé †ã®å•é¡Œ

MD5ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è‡ªä½“ã¯å˜ç´”ã§ã€ãƒ“ãƒƒãƒˆæ¼”ç®—ã•ãˆåˆ†ã‹ã‚Œã°ç‰¹æ®µé›£ã—ã„ã¨ã“ã‚ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å”¯ä¸€å¼•ã£æ›ã‹ã‚‹ã¨ã™ã‚Œã°[ãƒã‚¤ãƒˆé †](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3)ï¼ˆã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ï¼‰ã®å•é¡Œã§ã™ã€‚

RFC1321ã®æ–‡ä¸­ã€"low-order bytes first"ã‹ãã‚Œã¨åŒç­‰ãªè¡¨ç¾ãŒä½•åº¦ã‹ç™»å ´ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒãƒƒã‚·ãƒ¥åŒ–ã®å¯¾è±¡ã«ãªã‚‹å…ƒã®ãƒ“ãƒƒãƒˆåˆ—ã«å¯¾ã—ã¦ã€**ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³**ã®é †ã§èªã‚’èª­ã¿å–ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ãŒä½•ã§ã‚ã‚‹ã‹ï¼ˆã¨ã„ã†ã‹ãƒ“ãƒƒã‚°ã¨ãƒªãƒˆãƒ«ã®ã©ã£ã¡ãŒã©ã£ã¡ã‹ï¼‰ã¯å®Ÿä¾‹ã‚’è¦‹ã‚‹ã®ãŒæ‰‹ã£å–ã‚Šæ—©ã„ã§ã—ã‚‡ã†ã€‚Rustã§ã¯`byteorder`ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’dependenciesã«åŠ ãˆã‚‹ã“ã¨ã§åˆ©ç”¨ã§ãã¾ã™ã€‚

[byteorder \- crates\.io: Rust Package Registry](https://crates.io/crates/byteorder)

ä¾‹ã¨ã—ã¦ã€ãƒã‚¤ãƒˆåˆ—ã‚’32ãƒ“ãƒƒãƒˆã®èªã¨ã—ã¦èª­ã¿å–ã£ã¦ãƒãƒƒãƒ•ã‚¡ã¸æ›¸ãè¾¼ã‚€é–¢æ•°`read_u32_into`ã‚’è¦‹ã¾ã™ã€‚

Cargo.tomlã«
```
[dependencies]
byteorder = "1.4.3"
```

ã‚’æ›¸ãåŠ ãˆã¦ä»¥ä¸‹ã‚’å®Ÿè¡Œï¼š

```rust:byteorder_demo/src/main.rs
use byteorder::{BigEndian, ByteOrder, LittleEndian};

fn main() {
    let bytes: [u8; 12] = [
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x11, 0x22, 0x33, 0x44,
    ];
    let mut words: [u32; 3] = [0; 3];
    LittleEndian::read_u32_into(&bytes, &mut words);
    println!("{:x?}", words); //[67452301, efcdab89, 44332211]
    assert_eq!(words[0], 0x_67_45_23_01);
    assert_eq!(words[1], 0x_ef_cd_ab_89);
    assert_eq!(words[2], 0x_44_33_22_11);

    BigEndian::read_u32_into(&bytes, &mut words);
    println!("{:x?}", words); //[1234567, 89abcdef, 11223344]
    assert_eq!(words[0], 0x_01_23_45_67);
    assert_eq!(words[1], 0x_89_ab_cd_ef);
    assert_eq!(words[2], 0x_11_22_33_44);
}
```
[diy\_md5/main\.rs at main Â· roiban1344/diy\_md5](https://github.com/roiban1344/diy_md5/blob/main/byteorder_demo/src/main.rs)

ã‚½ãƒ¼ã‚¹ã¨ãªã‚‹é•·ã•12ã®ãƒã‚¤ãƒˆåˆ—`bytes`ã«å¯¾ã—ã¦ã€`words`ã¸ã¨`LittleEndian`, `BigEndian`ãã‚Œãã‚Œã®é †ã§32ãƒ“ãƒƒãƒˆã®èª3ã¤ãŒèª­ã¿å–ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®å ´åˆã€`LittleEndian`ã®ã»ã†ãŒ"low-order bytes first"ã§ã‚ã‚‹ã¨ã„ã†ã®ã¯ã€ã€Œ4ãƒã‚¤ãƒˆ=32ãƒ“ãƒƒãƒˆã‚’å˜ä½ã¨ã™ã‚‹èªã®ä¸‹ä½ã«æ¥ã‚‹ãƒ“ãƒƒãƒˆãŒãƒã‚¤ãƒˆã®åˆ—ä¸Šã§ã¯å‰æ–¹ã«æ¥ã‚‹ã€ã¨ã„ã†æ„å‘³ã«ãªã‚Šã¾ã™ã€‚ã€Œèªã€ã®é•·ã•ã¯å ´åˆã«ã‚ˆã‚Šã¾ã™ãŒã€RFC1321ã§ã¯ã“ã“ã«æŒ™ã’ãŸä¾‹ã¨åŒæ§˜ã€32ãƒ“ãƒƒãƒˆã‚’å˜ä½ã¨ã™ã‚‹å–ã‚Šæ±ºã‚ã«ãªã£ã¦ã„ã¾ã™ã€‚

# Rustã§å®Ÿè£…

RFC1321ã®*3. MD5 Algorithm Description* ã«æ²¿ã£ã¦å®Ÿè£…ã‚’é€²ã‚ã¦ã„ãã¾ã™ã€‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯Step 1.ã‹ã‚‰Step 5.ã«åˆ†ã‘ã¦èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚

## æº–å‚™

Rustã«ãŠã„ã¦ã€æ–‡å­—åˆ—ï¼š`String`ã‚„`str`å‹ã¯UTF-8ã«ã‚ˆã‚‹ç¬¦å·åŒ–ã§æœ‰åŠ¹ãªãƒ“ãƒƒãƒˆåˆ—ã§ã‚ã£ã¦ã€`char`ã‚„`u8`ã®é…åˆ—ã¨ã¯æ˜ç¢ºã«åŒºåˆ¥ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€`at`ã‚„`[]`ã§ç‰¹å®šä½ç½®ã®ãƒã‚¤ãƒˆã‚’è‡ªç”±ã«å–ã‚Šå‡ºã™ã“ã¨ã¯ã§ãã¾ã›ã‚“^[[Storing UTF\-8 Encoded Text with Strings \- The Rust Programming Language](https://doc.rust-lang.org/book/ch08-02-strings.html)
[String in std::string \- Rust](https://doc.rust-lang.org/std/string/struct.String.html)]ã€‚

æ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆã®ãƒ™ã‚¯ã‚¿ãƒ¼`Vec<u8>`ã¨ã—ã¦æ‰±ã†ãŸã‚ã€ã¾ãšä»¥ä¸‹ã®å¤‰æ›ã‚’è¡Œã„ã¾ã™ã€‚

```rust
let mut message = message.as_bytes().to_vec();
```

å¾Œè¿°ã™ã‚‹æ‰‹é †ã§ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆå»¶é•·ï¼‰ã‚’è¡Œã†ãŸã‚ã€`mut`ã§å¯å¤‰å¤‰æ•°ã¨ã—ã¦å®šç¾©ã—ã¾ã—ãŸã€‚

ã¾ãŸã€æ‰€æœ‰æ¨©ã‚’å¥ªã‚ãªã„ãŸã‚ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã¯`&str`ã«ã¨ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šä»¥ä¸‹ã®ã‚ˆã†ãªé–¢æ•°ã®ä¸­èº«ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

```rust
fn md5(message: &str) -> u128{
    todo!();
}
```

ãªãŠã€UTF-8ã§æ–‡å­—åˆ—ã‚’ç¬¦å·åŒ–ã—ã¦ãƒã‚¤ãƒˆã®åˆ—ã§è¡¨ç¾ã™ã‚‹æ–¹æ³•ã¯ä¸€æ„ã§ã‚ã‚‹ãŸã‚ã€`as_bytes`ã«ãƒã‚¤ãƒˆé †ã®å•é¡Œã¯ç”Ÿã˜ã¾ã›ã‚“^[[unicode \- Isnâ€™t on big endian machines UTF\-8's byte order different than on little endian machines? So why then doesnâ€™t UTF\-8 require a BOM? \- Stack Overflow](https://stackoverflow.com/questions/3833693/isn-t-on-big-endian-machines-utf-8s-byte-order-different-than-on-little-endian)]ã€‚ã€Œèªã€ï¼ˆã“ã®å ´åˆå˜ä¸€ã®æ–‡å­—ã®ç¬¦å·ä½ç½®ã®ã“ã¨ï¼‰ãŒå›ºå®šé•·ã§ã‚ã‚‹å½±éŸ¿ã§ãƒã‚¤ãƒˆé †ãŒå•é¡Œã«ãªã‚‹UTF-16ã‚„UTF-32ã¨ã¯å¯¾ç…§çš„ã§ã™ã€‚

## Step 1. Append Padding Bits

mod 512ã§448ã«åˆåŒãªãƒ“ãƒƒãƒˆé•·ã¾ã§ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¯¾ã—ã¦ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚

å…·ä½“çš„ã«ã¯ã€ã¾ãš`1`ã‚’è¿½åŠ ã—ã¦ã€ãã®å¾Œã‚ã«`0`ã‚’ç¶šã‘ã¾ã™^[1ã‚’è¿½åŠ ã™ã‚‹ã®ã¯ã“ã®æ“ä½œã‚’å¯é€†ã«ã—ã¦ã€è‡ªæ˜ãªè¡çªã‚’é˜²ããŸã‚ã§ã—ã‚‡ã†ã€‚]ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ“ãƒƒãƒˆé•·ãŒåˆã‚ã‹ã‚‰mod 512ã§448ã«ç­‰ã—ãã¦ã‚‚å¿…ãšè¡Œã„ã€ã—ãŸãŒã£ã¦ä»˜åŠ ã•ã‚Œã‚‹ãƒ“ãƒƒãƒˆåˆ—ã®é•·ã•ã¯æœ€å°1ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ“ãƒƒãƒˆé•· $\equiv 447\mod 512$ ã®ã¨ãï¼‰ã€æœ€å¤§512ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ“ãƒƒãƒˆé•· $\equiv 448\mod 512$ã®ã¨ãï¼‰ã«ãªã‚Šã¾ã™ã€‚

ä¾‹ï¼š

$$
\begin{align*}
\underbrace{1110010}_{å…ƒã®ãƒ“ãƒƒãƒˆé•·\,8}\rightarrow\underbrace{\underbrace{1110010}_{å…ƒã®ãƒ“ãƒƒãƒˆé•·\,8}\underbrace{1}_{1\,å€‹}\underbrace{00\cdots 0}_{439\,å€‹}}_{ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°å¾Œã®ãƒ“ãƒƒãƒˆé•·\,448}
\end{align*}
$$

ã„ã¾æ‰±ã†ã®ã¯ãƒã‚¤ãƒˆã®åˆ—é™å®šã§ã™ã€‚ã—ãŸãŒã£ã¦ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é•·ã•ã¯8ã®å€æ•°ãƒ“ãƒƒãƒˆã§ã™ã€‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒã‚¤ãƒˆé•· $m$ ã®64ã«å¯¾ã™ã‚‹å‰°ä½™ã‚’ $m\equiv r\,(0\leq 64\leq 63)\,\mod64$ ã¨ã—ã¾ã—ã‚‡ã†ã€‚$8r$ ãŒ $mod 512$ã§ã®**ãƒ“ãƒƒãƒˆé•·**ã®å‰°ä½™ã§ã™ã€‚

ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã®ãƒã‚¤ãƒˆé•· $p$ ã¯ã‚ˆã‚Šå…·ä½“çš„ã«ã¯ã€

$$
\begin{align*}
p &= \left\{\begin{array}{cc}
    56 - r & r < 56 \\
    120 - r & r \geq 56
\end{array}\right.
\end{align*}
$$

ã§ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚ä»¥ä¸‹ã«ç¤ºã™Rustã‚³ãƒ¼ãƒ‰ã§ã¯ã“ã®å¼ä¸­ã®å¤‰æ•°ã¯ãã‚Œãã‚Œ

- $m$ : `message_len_in_bytes`
- $r$ : `mod_64`
- $p$ : `padding_len_in_bytes`

ã¨å¯¾å¿œä»˜ã‘ã¾ã™ã€‚

```rust
    let message_len_in_bytes = message.len();
    let mod_64 = message_len_in_bytes & 0b111111; //ä¸‹ä½6ãƒ“ãƒƒãƒˆãŒ64ã«å¯¾ã™ã‚‹å‰°ä½™
    let padding_len_in_bytes = if mod_64 < 56 {
        56 - mod_64
    } else {
        120 - mod_64
    };
```

ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã§ã‚ã‚Šã†ã‚‹æœ€å¤§é•·ã•ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å®šæ•°é…åˆ— `PADDING` ã¨ã—ã¦æŒã£ã¦ãŠã„ã¦ã€ã“ã®é…åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹ã«ã‚ˆã£ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å»¶é•·ã—ã¾ã™ã€‚

```rust
const PADDING: [u8; 64] = [
    0b10000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
];
```

```rust
message.extend(&PADDING[..padding_len_in_bytes]);
```

## Step 2. Append Length
å…ƒã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ“ãƒƒãƒˆé•·ã®64ãƒ“ãƒƒãƒˆäºŒé€²è¡¨ç¾ï¼ˆã¤ã¾ã‚Š`u64`ï¼‰ã‚’32ãƒ“ãƒƒãƒˆã®èª2ã¤ã¨ã¿ãªã—ã€ä¸‹ä½ã®èªãŒå…ˆã«æ¥ã‚‹ã‚ˆã†ã«ã€Step1.ã§ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ«å°¾ã«è¿½åŠ ã—ã¾ã™ã€‚

ï¼Ÿï¼Ÿï¼Ÿ

> These bits are appended as two 32-bit words and appended low-order word first in accordance with the previous conventions.

......ã¨ã„ã†ã®ã¯RFC1321ã«æ›¸ã‹ã‚Œã¦ã„ã‚‹é€šã‚Šã®èª¬æ˜ã§ã™ãŒã€è¦ã¯64ãƒ“ãƒƒãƒˆã®èªã¨ã—ã¦è¦ç´ ã®å„ãƒã‚¤ãƒˆã‚’ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã§ä¸¦ã¹ã¾ã™ã€‚æ¨æ¸¬ã™ã‚‹ã«ã€*2. Terminology amd Notation*ã®é …ã§"word"ã‚’32ãƒ“ãƒƒãƒˆã¨è¦å®šã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã†ã„ã†ã‚„ã‚„å›ã‚Šãã©ã„èª¬æ˜ã«ãªã£ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã€‚

ä¾‹ï¼šå…ƒã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒ $776379490800$ ãƒ“ãƒƒãƒˆ $=97047436350$ ãƒã‚¤ãƒˆã®å ´åˆ

$$
\begin{align*}
(776379490800)_{10}=
&
({\rm b4c3d2e1f0})_{16}\\
&
\phantom{00000}
\hspace{-7pt}\searrow\hspace{-12pt}\swarrow\\
\underbrace{\underbrace{{\rm 1a2b3c4d5e\cdots ff}}_{97047436350ãƒã‚¤ãƒˆ}
\underbrace{8000\cdots 0}_{58ãƒã‚¤ãƒˆ}}_{\rm Step 1ã§ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸}
&
\underbrace{{\rm f0e1d2c3d4}}_{8ãƒã‚¤ãƒˆ}
\end{align*}
$$

ãƒ“ãƒƒãƒˆé•·ã®64ãƒ“ãƒƒãƒˆè¡¨ç¾ `8 * message_len_in_bytes as u64` ã‚’ã€`u8` ã®é•·ã•8ã®é…åˆ— `buf` ã¸ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã§æ›¸ãè¾¼ã¿ã€ãã‚Œã‚’Step 1ã§ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ«å°¾ã«æ›´ã«æ·»åŠ ã—ã¾ã™ã€‚

```rust
    let mut buf: [u8; 8] = [0; 8];
    LittleEndian::write_u64(&mut buf, 8 * message_len_in_bytes as u64);
    message.extend(&buf);
```

## Step 3. Initialize MD buffer
4ã¤ã®32ãƒ“ãƒƒãƒˆï¼ˆ=4ãƒã‚¤ãƒˆï¼‰ã®èªï¼ˆãƒãƒƒãƒ•ã‚¡ãƒ¼ï¼‰ã‚’ä»¥ä¸‹ã®å€¤ã§åˆæœŸåŒ–ã—ã¾ã™ã€‚
```
word A: 01 23 45 67
word B: 89 ab cd ef
word C: fe dc ba 98
word D: 76 54 32 10
```
Numeric separatorã‚’æŒŸã‚“ã§Rustã®ãƒªãƒ†ãƒ©ãƒ«ã§è¡¨ç¾ã™ã‚‹ã¨ã“ã†ãªã‚Šã¾ã™ï¼š
```rust
let mut A: u32 = 0x_67_45_23_01;
let mut B: u32 = 0x_ef_cd_ab_89;
let mut C: u32 = 0x_98_ba_dc_fe;
let mut D: u32 = 0x_10_32_54_76;
```

ãŸã ã—ã€Rustã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¤‰æ•°ã®å‘½åã«é–¢ã™ã‚‹è¦å®šã§ã¯ã€å¤‰æ•°ã¯å°æ–‡å­—ã®ã‚¹ãƒãƒ¼ã‚¯ã‚±ãƒ¼ã‚¹ã§ã‚ã‚‹ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚`#[allow(non_snake_case)]` å±æ€§ã‚’ä»˜ã‘ã‚‹ã“ã¨ã§è­¦å‘Šã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ã¯å¯èƒ½^[[rust \- Is there some way to not show a warning for non snake case identifiers? \- Stack Overflow](https://stackoverflow.com/questions/36344415/is-there-some-way-to-not-show-a-warning-for-non-snake-case-identifiers)]ã§ã™ãŒã€ã“ã“ã§ã¯å‘½åæŒ‡é‡ã«å¾“ã†ã“ã¨ã«ã—ã¦å°æ–‡å­—ã§å®šç¾©ã—ã¾ã™ã€‚

```rust
let mut a = 0x67452301u32;
let mut b = 0xefcdab89u32;
let mut c = 0x98badcfeu32;
let mut d = 0x10325476u32;
```

ã¡ãªã¿ã« `a=1732584193` ã ã‘ç´ æ•°ã§ã™ã€‚

## Step 4.Process Message in 16-word Blocks
ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸ512ã®å€æ•°ã®ãƒ“ãƒƒãƒˆé•·ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã€å…ˆé ­ã‹ã‚‰32ãƒ“ãƒƒãƒˆã®èªã‚’å˜ä½ã¨ã—ã¦ã€Step 3ã§å®šç¾©ã•ã‚ŒãŸ `A,B,C,D` ã¸ä½œç”¨ã•ã›ã¦ã„ãã¾ã™ã€‚RFC1321ã§ã¯"Step 4."ã§ä¸€æ‹¬ã‚Šã«ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã“ã§ã¯4.1ã‹ã‚‰4.3ã«åˆ†ã‘ã¦è¦‹ã¦ã„ãã¾ã™ã€‚
### 4.1 è£œåŠ©é–¢æ•°
32ãƒ“ãƒƒãƒˆã®èª3ã¤ã‚’ã¨ã£ã¦32ãƒ“ãƒƒãƒˆã®èª1ã¤ã‚’è¿”ã™ã€4ã¤ã®è£œåŠ©çš„ãªé–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚
```
F(X,Y,Z) = XY v not(X) Z
G(X,Y,Z) = XZ v Y not(Z)
H(X,Y,Z) = X xor Y xor Z
I(X,Y,Z) = Y xor (X v not(Z))
```

ãƒ“ãƒƒãƒˆæ¼”ç®—ã«é–¢ã™ã‚‹RFC1321ä¸­ã®ä¸Šã®è¡¨ç¾ã¨Rustã§ã®è¡¨ç¾ã¯ä¸‹è¡¨ã§å¯¾å¿œä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚

|RFC1321|Rust|
|---|---|
|`XY`|  `X & Y`|
|`X v Y`|`X \| Y`|
|`not(X)`|`!X`|
|`X xor Y`|`X^Y`|

[æ¼”ç®—å­ã®è©•ä¾¡é †åº](https://doc.rust-lang.org/reference/expressions.html#expression-precedence)ã¯RFC132ã¨Rustã§ä¸€è‡´ã—ã¦ã„ã¾ã™ã€‚

ã“ã®é–¢æ•°ã‚‚å°æ–‡å­—ã§å®šç¾©ã—ã¾ã™ã€‚`i` ã‚’ãƒ«ãƒ¼ãƒ—ã®ãƒ€ãƒŸãƒ¼å¤‰æ•°ä»¥å¤–ã®ç”¨é€”ã§ç”¨ã„ã‚‹ã®ãŒå¾®å¦™ã§ã™ãŒã€ã¾ã‚ç™»å ´ã—ãªã„ã®ã§å•é¡Œãªã„ã§ã—ã‚‡ã†ã€‚

```rust
fn f(x: u32, y: u32, z: u32) -> u32 {
    x & y | !x & z
}

fn g(x: u32, y: u32, z: u32) -> u32 {
    x & z | y & !z
}

fn h(x: u32, y: u32, z: u32) -> u32 {
    x ^ y ^ z
}

fn i(x: u32, y: u32, z: u32) -> u32 {
    y ^ (x | !z)
}
```

ã¨ã“ã‚ã§ã€ã“ã®RFC1321ã®ã“ã®ç®‡æ‰€ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªè¨˜è¿°ãŒã‚ã‚Šã¾ã™ã€‚

> if the bits of X, Y, and Z are independent and unbiased, the each bit of F(X,Y,Z) will be independent and unbiased.

> if the corresponding bits of X, Y, and Z are independent and unbiased, then each bit of G(X,Y,Z), H(X,Y,Z), and I(X,Y,Z) will be independent and unbiased.

ã©ã†ã„ã†ã“ã¨ã§ã—ã‚‡ã†ã‹ã€‚

`F,G,H,I` ã¯å…¨ã¦ãƒ“ãƒƒãƒˆæ¯ï¼ˆbit-wiseï¼‰ãªæ¼”ç®—ã‹ã‚‰æˆã‚‹é–¢æ•°ã§ã‚ã‚‹ãŸã‚ã€å¼•æ•°ã¨è¿”ã‚Šå€¤ã®é–¢ä¿‚ã¯ `(x,y,z)=(0,0,0),(0,0,1),...,(1,1,1)` ã®8é€šã‚Šã§æœ¬è³ªçš„ã«ã¯å°½ãã¦ã„ã¾ã™ã€‚å®Ÿéš›ã«è¨ˆç®—ã—ã¦ã¿ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ãªé–¢ä¿‚ã«ãªã‚Šã¾ã™ã€‚

```rust
    for xyz in 0..8 {
        let (x, y, z) = ((xyz >> 2) & 1, (xyz >> 1) & 1, xyz & 1);
        let f = f(x, y, z) & 1;
        let g = g(x, y, z) & 1;
        let h = h(x, y, z) & 1;
        let i = i(x, y, z) & 1;
        println!("{:03b} {} {} {} {}", xyz, f, g, h, i);
    }
```
å‡ºåŠ›ï¼š
```
xyz F G H I
000 0 0 0 1
001 1 0 1 0
010 0 1 1 0
011 1 0 0 1
100 0 0 1 1
101 0 1 0 1
110 1 1 0 0
111 1 1 1 0
```

å„é–¢æ•°ã§è¿”ã‚Šå€¤ã®0ã¨1ãŒã¡ã‚‡ã†ã©4ãšã¤ç¾ã‚Œã¦ã„ã‚‹ã“ã¨ãŒè¦³å¯Ÿã§ãã¾ã™ã€‚ãŠãã‚‰ãã“ã®ã“ã¨ã‚’è¨€ã£ã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†^[ãŸã "independent and unbiased"ã¨ã„ã†è¡¨ç¾ãŒæ°—ã«ãªã‚Šã¾ã™ã€‚"Unbiased"ã¯æ•°ãˆä¸Šã’ã‚Œã°ã„ã„ã¨ã—ã¦ã€"independent"ã¨ã„ã†æ€§è³ªã¯ã“ã®çµæœã‹ã‚‰ç¢ºã‹ã‚ã‚‰ã‚Œã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ]ã€‚

### 4.2 512ãƒ“ãƒƒãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯ã¸ã®åˆ‡ã‚Šå‡ºã—
ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚Œã¦512ã®å€æ•°ã®ãƒ“ãƒƒãƒˆé•·ã«ãªã£ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å…ˆé ­ã‹ã‚‰512ãƒ“ãƒƒãƒˆï¼ˆ=64ãƒã‚¤ãƒˆï¼‰ã®ã€Œãƒ–ãƒ­ãƒƒã‚¯ã€ã‚’åˆ‡ã‚Šå‡ºã—ã€ã•ã‚‰ã«ãã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’16å€‹ã®32ãƒ“ãƒƒãƒˆï¼ˆ=4ãƒã‚¤ãƒˆï¼‰ã®èªã«åˆ†å‰²ã—ã¾ã™ã€‚ã“ã®16å€‹ã®èªã‚’ä½¿ã£ã¦`A, B, C, D`ã‚’ãƒ©ã‚¦ãƒ³ãƒ‰1ã‹ã‚‰4ã¾ã§ã®æ“ä½œï¼ˆãã‚Œãã‚Œ`F, G, H, I`ã‚’åˆ©ç”¨ï¼‰1ã‚»ãƒƒãƒˆï¼ˆ4.3ã§å¾Œè¿°ï¼‰ã§å¤‰æ›ã—ã¾ã™ã€‚ãƒ–ãƒ­ãƒƒã‚¯ãŒå…¨ã¦ãªããªã‚‹ã¾ã§åŒã˜ã‚»ãƒƒãƒˆã‚’ç¹°ã‚Šè¿”ã—ã¾ã™ã€‚

ã€Œãƒ–ãƒ­ãƒƒã‚¯ã®åˆ‡ã‚Šå‡ºã—ã€ã¯ `std::io::Cursor` ã® `read` ã«ã‚ˆã£ã¦å®Ÿç¾ã—ã¾ã™ã€‚`read` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ `Read` ãƒˆãƒ¬ã‚¤ãƒˆã«å«ã¾ã‚Œã‚‹ãŸã‚ã€ã“ã‚Œã‚‚ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã‚Œã¾ã™ã€‚

```rust
use std::io::{Cursor, Read};
```

[Cursor in std::io \- Rust](https://doc.rust-lang.org/std/io/struct.Cursor.html#method.read)

`Cursor` ã¯ `read` ã§èª­ã¿å–ã£ãŸåˆ†æ¬¡å›ã®èª­ã¿å–ã‚Šä½ç½®ã‚’ç§»å‹•ã™ã‚‹ãŸã‚ã€ãƒ«ãƒ¼ãƒ—å¤‰æ•°ã«ã‚ˆã‚‹èª­ã¿å–ã‚Šä½ç½®ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¯ä¸è¦ã§ã™ã€‚ã¾ãŸã€`read` ã®è¿”ã‚Šå€¤ã¯ `Result` å‹ã§ã‚ã‚‹ãŸã‚ã€`unwrap` ã§å€¤ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚å…¨ã¦èª­ã¿çµ‚ã‚ã£ãŸå¾Œã§å°šèª­ã¿å–ã‚ã†ã¨ã—ãŸå ´åˆ `Err` å‹ãŒè¿”ã‚‹ãŸã‚ã“ã‚Œã«ã‚ˆã£ã¦ãƒ«ãƒ¼ãƒ—ã‚’åœæ­¢ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€èª­ã¿å–ã‚Šå›æ•°ã¯ (ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒã‚¤ãƒˆé•·)/64 ã§æ±ºã¾ã£ã¦ã„ã‚‹ãŸã‚ã€ã“ã®å›æ•°ã ã‘ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚


```rust
    let mut cursor = Cursor::new(&message);
    let n = message.len() >> 6;

    for _ in 0..n {
        let mut block = [0; 64];
        cursor.read(&mut block).unwrap();
        todo!();ã€€//4.3ã§å®Ÿè£…
    }
```

512ãƒ“ãƒƒãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’32ãƒ“ãƒƒãƒˆã®èª16å€‹ã«åˆ†å‰²ã—ã¾ã™ã€‚æ—¢ã«ç™»å ´ã—ã¾ã—ãŸãŒã€`LittleEndian` ã® `read_u32_into` ã®ã‚·ã‚°ãƒãƒãƒ£ã¯

```rust
fn read_u32_into(src: &[u8], dst: &mut [u32])
```

ã¨ãªã£ã¦ãŠã‚Šã€ãƒã‚¤ãƒˆåˆ— `src` ã‚’32ãƒ“ãƒƒãƒˆã®èªã®é…åˆ— `dst` ã«æ›¸ãè¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚

```rust
let mut x: [0u32; 16] = [0; 16];
LittleEndian::read_u32_into(&block, &mut x);
```

ã“ã†ã—ã¦ `x` ã«32ãƒ“ãƒƒãƒˆã®èª16å€‹ãŒæ›¸ãè¾¼ã¾ã‚Œã¾ã—ãŸã€‚

### 4.3 ãƒãƒƒãƒ•ã‚¡ã¸ä½œç”¨

`A, B, C, D` ã«å¯¾ã—ã¦èªã‚’ä½œç”¨ã•ã›ã¦ã„ãã¾ã™ã€‚

å‡¦ç†ã¯ãƒ©ã‚¦ãƒ³ãƒ‰1ã‹ã‚‰4ã¾ã§ã‚ã‚Šã€ãƒ©ã‚¦ãƒ³ãƒ‰1ã¯ä»¥ä¸‹ã®ç–‘ä¼¼ã‚³ãƒ¼ãƒ‰ã§è¡¨ã•ã‚Œã¾ã™ã€‚
```
     /* Round 1. */
     /* Let [abcd k s i] denote the operation
          a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
     /* Do the following 16 operations. */
     [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
     [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
     [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
     [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]
```

ãƒ©ã‚¦ãƒ³ãƒ‰2, 3, 4ã§ã¯åŒæ§˜ã®æ“ä½œã‚’ã€`F` ã‚’ `G`, `H`, `I` ã«ç½®ãæ›ãˆã¦è¡Œã„ã¾ã™ã€‚

`+`ã¯`mod 32`ã«ã‚ˆã‚‹å’Œã§ã™ã€‚ä¸€è¦‹ã‚ã–ã‚ã–èª¬æ˜ã™ã‚‹ã¾ã§ã‚‚ãªã„ã“ã¨ã®ã‚ˆã†ã«æ€ã‚ã‚Œã¾ã™ãŒã€Rustã¯ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã«ã‚ˆã‚‹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã¯ã€`+`æ¼”ç®—å­ã«ã‚ˆã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã‚’æ¤œçŸ¥ã—ã¦`panic!`ã‚’èµ·ã“ã™ãŸã‚æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚

æœ€ã‚‚è’ã£ã½ãã“ã‚Œã‚’è§£æ¶ˆã™ã‚‹æ–¹æ³•ã¯ãƒªãƒªãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰(Cargoãªã‚‰`--release`ã‚ªãƒ—ã‚·ãƒ§ãƒ³)ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ã§ã™ã€‚`#![allow(arithmetic_overflow)]`å±æ€§ã§æ˜ç¤ºçš„ã«ãƒã‚§ãƒƒã‚¯ã‚’æŠ‘åˆ¶ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

çœŸã£å½“ãªè§£æ±ºæ–¹æ³•ã¯ã€æ•°å€¤å‹ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ `wrapping_add` ã‚’ä½¿ã†ã“ã¨ã§ã™^[[u32 wrapping_add \- Rust](https://doc.rust-lang.org/std/primitive.u32.html#method.wrapping_add)
[How can integer overflow protection be turned off? \- Stack Overflow](https://stackoverflow.com/questions/31215139/how-can-integer-overflow-protection-be-turned-off)]ã€‚å°‘ã€…èª­ã¿ã«ããã¯ãªã‚Šã¾ã™ãŒã€`u32`ãªã‚‰ $\mod 2^{32}$ ã«ã‚ˆã‚‹è¨ˆç®—ã‚’ä¿è¨¼ã•ã‚ŒãŸæŒ™å‹•ã¨ã—ã¦å®Ÿè¡Œã§ãã¾ã™ã€‚

`T[i]` ã¯ $2^{32} |\sin(i)|$ ï¼ˆå¼•æ•°ã¯ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ï¼‰ã®æ•´æ•°éƒ¨åˆ†ã§ã™ï¼ˆä»˜éŒ²å‚ç…§ï¼‰ã€‚å€¤ã¯å®šæ•°ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã—ã¦ç”¨æ„ã—ã¦ãŠãã¾ã™ã€‚

```rust
const T: [u32; 65] = [
    0, 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,
    0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
    0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x2441453, 0xd8a1e681,
    0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9,
    0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60,
    0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,
    0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
    0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,
    0xeb86d391,
];
```

ï¼ˆ`T[0]` ã¯ä¸ä½¿ç”¨ã ãŒè¨˜æ³•ã‚’ä¸€è‡´ã•ã›ã‚‹ãŸã‚ã«ä¿æŒï¼‰

`<<<` ã¯å·¦æ–¹å‘ã¸ã®[å·¡å›ã‚·ãƒ•ãƒˆ](https://en.wikipedia.org/wiki/Bitwise_operation#Circular_shift)ã§ã™ã€‚`rotate_left` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ`u32`ã«å‚™ã‚ã£ã¦ã„ã¾ã™^[[u32 rotate_left \- Rust](https://doc.rust-lang.org/std/primitive.u32.html#method.rotate_left)]ã€‚

Rustã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ‰ã§ã‚‚ç•¥è¨˜æ³• `[abcd k s i]` ã‚’ä½¿ãˆã‚‹ã¨å¬‰ã—ãã†ã§ã™ã€‚é–¢æ•°ã‚„ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¨ã—ã¦å®šç¾©ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€`x` ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æ­£ã—ãè€ƒæ…®ã—ãŸã‚Šã€`F,G,H,I` ã®éƒ¨åˆ†ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨ãªã‹ãªã‹é¢å€’ã§ã™ã€‚

ã€Œãƒã‚¯ãƒ­ã‚’å®šç¾©ã™ã‚‹ãƒã‚¯ãƒ­ã€ã§å®Ÿç¾ã—ã¦ã—ã¾ã†ã“ã¨ã«ã—ã¾ã™ã€‚

```rust
macro_rules! define_operation {
    ($macro_name:ident, $f:expr) => {
        macro_rules! $macro_name {
            ($a:expr, $b:expr, $c:expr, $d:expr, $k:expr, $s:expr, $i:expr) => {
                $a = $b.wrapping_add(
                    $a.wrapping_add(
                        $f($b, $c, $d).wrapping_add(x[$k]).wrapping_add(T[$i]),
                    )
                    .rotate_left($s),
                );
            };
        }
    };
}
```

ã“ã®ãƒã‚¯ãƒ­ã‚’ä½¿ã†ã¨ã€ãƒ©ã‚¦ãƒ³ãƒ‰1ãŒä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™ã€‚è§’æ‹¬å¼§ã‚’ä½¿ã£ã¦RFC1321ã¨è¦‹ãŸç›®ã‚’æƒãˆã‚‰ã‚Œã‚‹ç‚¹ã‚‚äº›ç´°ãªãŒã‚‰å¬‰ã—ã„ã§ã™ã€‚

```rust
define_operation!(ff, f);
ff![a, b, c, d, 0, 7, 1];
ff![d, a, b, c, 1, 12, 2];
ff![c, d, a, b, 2, 17, 3];
ff![b, c, d, a, 3, 22, 4];
ff![a, b, c, d, 4, 7, 5];
ff![d, a, b, c, 5, 12, 6];
ff![c, d, a, b, 6, 17, 7];
ff![b, c, d, a, 7, 22, 8];
ff![a, b, c, d, 8, 7, 9];
ff![d, a, b, c, 9, 12, 10];
ff![c, d, a, b, 10, 17, 11];
ff![b, c, d, a, 11, 22, 12];
ff![a, b, c, d, 12, 7, 13];
ff![d, a, b, c, 13, 12, 14];
ff![c, d, a, b, 14, 17, 15];
ff![b, c, d, a, 15, 22, 16];
```

åŒæ§˜ã«ã€ãƒã‚¯ãƒ­å®šç¾©\+æ“ä½œã‚’ãƒ©ã‚¦ãƒ³ãƒ‰2ã‹ã‚‰4ã¾ã§æ›¸ãã¾ã™ã€‚

ãƒ©ã‚¦ãƒ³ãƒ‰1ã‹ã‚‰4çµ‚äº†å¾Œã«ã€ãƒ©ã‚¦ãƒ³ãƒ‰1é–‹å§‹å‰ã®å€¤ã‚’`A, B, C, D`ã«åŠ ãˆã¾ã™ã€‚ã“ã‚ŒãŒ512ãƒ“ãƒƒãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯ã«å¯¾ã™ã‚‹æ“ä½œ1ã‚»ãƒƒãƒˆã§ã™ã€‚

```rust
let (aa, bb, cc, dd) = (a, b, c, d);
/* Round 1 */
/* Round 2 */
/* Round 3 */
/* Round 4 */
a = a.wrapping_add(aa);
b = b.wrapping_add(bb);
c = c.wrapping_add(cc);
d = d.wrapping_add(dd);
```

ã“ã®æ“ä½œ1ã‚»ãƒƒãƒˆã‚’ã€ãƒ–ãƒ­ãƒƒã‚¯ãŒãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æœ«å°¾ã«é”ã™ã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—ã¾ã™ã€‚

## Step 5. Output

Step 4ã®æ“ä½œãŒå®Œäº†ã—ãŸå¾Œã€`A,B,C,D` ã‚’ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã§ãƒ“ãƒƒãƒˆåˆ—ã¨ã—ã¦çµåˆã—ã¾ã™ã€‚ä¾‹ã¨ã—ã¦ã€

```rust
A = 0xaeb0434b;
B = 0xcd2456e3;
C = 0x1810b995;
D = 0x31c23d9b;
```
ãªã‚‰ã€
```
4b43b0aee35624cd95b910189b3dc231
```
ãŒæœ€çµ‚çš„ãªãƒãƒƒã‚·ãƒ¥å€¤ã«ãªã‚Šã¾ã™ã€‚å®Ÿè£…ã¨ã—ã¦ã¯ã€é•·ã•16ã®ãƒã‚¤ãƒˆã®é…åˆ—ã«ãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã§æ›¸ãè¾¼ã‚“ã å¾Œã€ãƒ“ãƒƒã‚°ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ã§èª­ã¿å–ã‚Œã°ã‚ˆã„ã§ã™ã€‚

```rust
    let mut buf: [u8;16] = [0; 16];
    LittleEndian::write_u32_into(&[a, b, c, d], &mut buf);
    BigEndian::read_u128(&buf)
```

ä»¥ä¸‹ã«ã‚³ãƒ¼ãƒ‰ã®å…¨ä½“ã‚’ã¾ã¨ã‚ã¾ã™ã€‚RFC1321 A.5ã«ä»˜è¨˜ã•ã‚Œã¦ã„ã‚‹ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å«ã‚ã¾ã—ãŸã€‚

:::details ã‚³ãƒ¼ãƒ‰å…¨ä½“
```rust:diy_md5/lib.rs
use byteorder::{ByteOrder, BE, LE};
use std::io::{Cursor, Read};

const PADDING: [u8; 64] = [
    0b10000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
];

const T: [u32; 65] = [
    0, 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,
    0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
    0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x2441453, 0xd8a1e681,
    0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9,
    0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60,
    0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,
    0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
    0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,
    0xeb86d391,
];

fn f(x: u32, y: u32, z: u32) -> u32 {
    x & y | !x & z
}

fn g(x: u32, y: u32, z: u32) -> u32 {
    x & z | y & !z
}

fn h(x: u32, y: u32, z: u32) -> u32 {
    x ^ y ^ z
}

fn i(x: u32, y: u32, z: u32) -> u32 {
    y ^ (x | !z)
}

pub fn md5(message: &str) -> u128 {
    let mut message = message.as_bytes().to_vec();

    /* Step 1. Append Padding Bits */
    let message_len_in_bytes = message.len();
    let mod_64 = message_len_in_bytes & 0b111111;
    let padding_len_in_bytes = if mod_64 < 56 {
        56 - mod_64
    } else {
        120 - mod_64
    };
    message.extend(&PADDING[..padding_len_in_bytes]);

    /* Step 2. Append Length */
    let mut buf = [0; 8];
    LE::write_u64(&mut buf, 8 * message_len_in_bytes as u64);
    message.extend(&buf);

    /* Step 3. Initialize MD Buffer */
    let mut a = 0x67452301u32;
    let mut b = 0xefcdab89u32;
    let mut c = 0x98badcfeu32;
    let mut d = 0x10325476u32;

    /* Step 4. Process Message in 16-Word Blocks */
    let mut cursor = Cursor::new(&message);
    let n = message.len() >> 6;
    for _ in 0..n {
        let mut block = [0; 64];
        cursor.read(&mut block).unwrap();
        let mut x = [0; 16];
        LE::read_u32_into(&block, &mut x);
        macro_rules! define_operation {
            ($macro_name: ident, $func: ident) => {
                macro_rules! $macro_name {
                    ($a:expr, $b:expr, $c:expr, $d: expr, $k:expr, $s:expr, $i:expr) => {
                        $a = $b.wrapping_add(
                            $a.wrapping_add($func($b, $c, $d))
                                .wrapping_add(x[$k])
                                .wrapping_add(T[$i])
                                .rotate_left($s),
                        )
                    };
                }
            };
        }
        let (aa, bb, cc, dd) = (a, b, c, d);

        /* Round 1. */
        define_operation!(ff, f);
        ff![a, b, c, d, 0, 7, 1];
        ff![d, a, b, c, 1, 12, 2];
        ff![c, d, a, b, 2, 17, 3];
        ff![b, c, d, a, 3, 22, 4];
        ff![a, b, c, d, 4, 7, 5];
        ff![d, a, b, c, 5, 12, 6];
        ff![c, d, a, b, 6, 17, 7];
        ff![b, c, d, a, 7, 22, 8];
        ff![a, b, c, d, 8, 7, 9];
        ff![d, a, b, c, 9, 12, 10];
        ff![c, d, a, b, 10, 17, 11];
        ff![b, c, d, a, 11, 22, 12];
        ff![a, b, c, d, 12, 7, 13];
        ff![d, a, b, c, 13, 12, 14];
        ff![c, d, a, b, 14, 17, 15];
        ff![b, c, d, a, 15, 22, 16];

        /* Round 2. */
        define_operation!(gg, g);
        gg![a, b, c, d, 1, 5, 17];
        gg![d, a, b, c, 6, 9, 18];
        gg![c, d, a, b, 11, 14, 19];
        gg![b, c, d, a, 0, 20, 20];
        gg![a, b, c, d, 5, 5, 21];
        gg![d, a, b, c, 10, 9, 22];
        gg![c, d, a, b, 15, 14, 23];
        gg![b, c, d, a, 4, 20, 24];
        gg![a, b, c, d, 9, 5, 25];
        gg![d, a, b, c, 14, 9, 26];
        gg![c, d, a, b, 3, 14, 27];
        gg![b, c, d, a, 8, 20, 28];
        gg![a, b, c, d, 13, 5, 29];
        gg![d, a, b, c, 2, 9, 30];
        gg![c, d, a, b, 7, 14, 31];
        gg![b, c, d, a, 12, 20, 32];

        /* Round 3. */
        define_operation!(hh, h);
        hh![a, b, c, d, 5, 4, 33];
        hh![d, a, b, c, 8, 11, 34];
        hh![c, d, a, b, 11, 16, 35];
        hh![b, c, d, a, 14, 23, 36];
        hh![a, b, c, d, 1, 4, 37];
        hh![d, a, b, c, 4, 11, 38];
        hh![c, d, a, b, 7, 16, 39];
        hh![b, c, d, a, 10, 23, 40];
        hh![a, b, c, d, 13, 4, 41];
        hh![d, a, b, c, 0, 11, 42];
        hh![c, d, a, b, 3, 16, 43];
        hh![b, c, d, a, 6, 23, 44];
        hh![a, b, c, d, 9, 4, 45];
        hh![d, a, b, c, 12, 11, 46];
        hh![c, d, a, b, 15, 16, 47];
        hh![b, c, d, a, 2, 23, 48];

        /* Round 4. */
        define_operation!(ii, i);
        ii![a, b, c, d, 0, 6, 49];
        ii![d, a, b, c, 7, 10, 50];
        ii![c, d, a, b, 14, 15, 51];
        ii![b, c, d, a, 5, 21, 52];
        ii![a, b, c, d, 12, 6, 53];
        ii![d, a, b, c, 3, 10, 54];
        ii![c, d, a, b, 10, 15, 55];
        ii![b, c, d, a, 1, 21, 56];
        ii![a, b, c, d, 8, 6, 57];
        ii![d, a, b, c, 15, 10, 58];
        ii![c, d, a, b, 6, 15, 59];
        ii![b, c, d, a, 13, 21, 60];
        ii![a, b, c, d, 4, 6, 61];
        ii![d, a, b, c, 11, 10, 62];
        ii![c, d, a, b, 2, 15, 63];
        ii![b, c, d, a, 9, 21, 64];

        a = a.wrapping_add(aa);
        b = b.wrapping_add(bb);
        c = c.wrapping_add(cc);
        d = d.wrapping_add(dd);
    }

    /* Step 5. Output */
    let mut buf = [0; 16];
    LE::write_u32_into(&[a, b, c, d], &mut buf);
    BE::read_u128(&buf)
}

[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        use super::*;

        assert_eq!(md5(""), 0xd41d8cd98f00b204e9800998ecf8427e);
        assert_eq!(md5("a"), 0x0cc175b9c0f1b6a831c399e269772661);
        assert_eq!(md5("abc"), 0x900150983cd24fb0d6963f7d28e17f72);
        assert_eq!(md5("message digest"), 0xf96b697d7cb7938d525a2f31aaf161d0);
        assert_eq!(
            md5("abcdefghijklmnopqrstuvwxyz"),
            0xc3fcd3d76192e4007dfb496cca67e13b
        );
        assert_eq!(
            md5("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
            0xd174ab98d277d9f5a5611c2c9f419d9f
        );
        assert_eq!(
            md5("12345678901234567890123456789012345678901234567890123456789012345678901234567890"),
            0x57edf4a22be3c955ac49da2e2107b67a
        );
    }
}

```
:::

[diy\_md5/lib\.rs at main Â· roiban1344/diy\_md5](https://github.com/roiban1344/diy_md5/blob/main/diy_md5/src/lib.rs)

ãªãŠã€`LE, BE`ã¯ãã‚Œãã‚Œ`LittleEndian, BigEndian`ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚ã¾ãŸã€å‹æ¨è«–ãŒå¯èƒ½ãªå ´æ‰€ã®æ³¨é‡ˆã¯çœç•¥ã—ã¾ã—ãŸã€‚

ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã¯ASCIIã®ç¯„å›²ã—ã‹æ‰±ã£ã¦ã„ã¾ã›ã‚“ãŒã€æ¼¢å­—ã‚„çµµæ–‡å­—ã‚’å«ã‚“ã§ã„ã¦ã‚‚ãƒãƒƒã‚·ãƒ¥åŒ–ã§ãã¾ã™ã€‚

ä¾‹ãˆã°ã€ã‚´ã‚¸ãƒ©SPã«ã‚‚ç™»å ´ã—ãŸ"è§£ã‘ã°ã‚ã‹ã‚‹"ã®ãƒãƒƒã‚·ãƒ¥å€¤ãŒ`0x14980c8b8a96fd9e279796a61cf82c9c`ã§ã‚ã‚‹ã“ã¨ã‚‚ç¢ºã‹ã‚ã‚‰ã‚Œã¾ã™ã€‚

```rust:diy_md5/main.rs
fn main(){
    //ã²ã‚‰ãŒãªã¨æ¼¢å­—ã‚’å«ã‚€æ–‡å­—åˆ—
    let hash = diy_md5::md5("è§£ã‘ã°ã‚ã‹ã‚‹");
    println!("{:032x}", hash);
    assert_eq!(0x14980c8b8a96fd9e279796a61cf82c9c, hash);

    //è¡¨è¨˜æºã‚Œã§å…¨ãç•°ãªã‚‹å€¤ã«ãªã‚‹
    let hash = diy_md5::md5("è§£ã‘ã°åˆ†ã‹ã‚‹");
    println!("{:032x}", hash); //606461eb515ea6d825117fbe76965899

    //emoji
    let hash = diy_md5::md5("ğŸ¶");
    println!("{:032x}", hash); //be0f7766d0c41a4386d47e18e8b91e15
}
```

[diy\_md5/main\.rs at main Â· roiban1344/diy\_md5](https://github.com/roiban1344/diy_md5/blob/main/diy_md5/src/main.rs)

# ä»˜éŒ²ã€€sin(i)ã‚’è¨ˆç®—
ãŠã¾ã‘ã§ã™ã€‚Step 4.ã«ç™»å ´ã™ã‚‹å®šæ•°ãŸã¡ $T_i = \lfloor 4294967296\,|\sin(i)|\rfloor (1\leq i \leq 64)$ ã‚’è¨ˆç®—ã—ã¾ã—ã‚‡ã†ã€‚

## ãƒ†ã‚¤ãƒ©ãƒ¼ã®å®šç†

[ãƒ†ã‚¤ãƒ©ãƒ¼ã®å®šç†](https://ja.wikipedia.org/wiki/%E3%83%86%E3%82%A4%E3%83%A9%E3%83%BC%E3%81%AE%E5%AE%9A%E7%90%86)ãŒåŸºæœ¬ã§ã™ï¼š

åŒºé–“ $[0, a]\in \mathbb{R}$ ã§ $n+1$ å›å¾®åˆ†ãªé–¢æ•° $f:\mathbb{R}\mapsto \mathbb{R}$ ã«ã¤ã„ã¦ã€ä»»æ„ã® $x\in [0,a]$ ã«å¯¾ã—ã¦

$$
\begin{align*}
f(x) = \sum_{k=0}^n \frac{f^{(k)}(0)}{k!}x^k + \frac{f^{(n+1)}(c)\,x^{n+1}}{(n+1)!}
\end{align*}
$$

ã¨ãªã‚‹ $c\in (0,a)$ ãŒå­˜åœ¨ã™ã‚‹ã€‚

é¦´æŸ“ã¿æ·±ã„å®šç†ã§ã™ãŒã€èª¤å·®ã‚’æ­£ã—ãè©•ä¾¡ã—ã¦è¨ˆç®—ã™ã‚‹ã¨ãªã‚‹ã¨ãªã‹ãªã‹å¤§å¤‰ã§ã™ã€‚

ç¬¬ $n$ éƒ¨åˆ†å’Œã‚’ $S_{n}:=\sum_{k=0}^n f^{(k)}(0)x^k/k!$ã€ãã®èª¤å·®é …ã‚’ $R_{n}:=f^{n+1}(c)x^{n+1}/(n+1)!$ ã¨ã—ã¾ã™ã€‚

$f(x) = \sin x$ ã®å ´åˆã€$|f^{(n)}(c)|\leq 1$ ã§ã‚ã‚‹ãŸã‚ã€å…¨ã¦ã® $x\in \mathbb{R}$ ã§ $\lim_{n\rightarrow \infty} R_{n}=0$ ã¨èª¤å·®é …ãŒ $0$ ã«åæŸã—ã€éƒ¨åˆ†å’Œã¯çœŸã®å€¤ã«åæŸã—ã¾ã™ã€‚ã•ã‚‰ã«ã€$W_n:=|x^{n+1}/(n+1)!|$ ã¨ã™ã‚‹ã¨ã€

$$
\begin{align}
S_n-W_n \leq \sin x \leq S_n+W_n
\end{align}
$$

ã¯å³å¯†ãªè©•ä¾¡ã«ãªã‚Šã¾ã™ã€‚$\lfloor 4294967296| \sin x|\rfloor$ ã®å€¤ãŒç¢ºå®šã™ã‚‹ãŸã‚ã«ã¯ã€

- $S_n-W_n$ ã¨ $S_n+W_n$ ã®ç¬¦å·ãŒä¸€è‡´
- $\lfloor 4294967296 |S_n-W_n|\rfloor = \lfloor 4294967296 |S_n+W_n|\rfloor$

ã¨ãªã‚Œã°ã‚ˆã„ã§ã™ã€‚

## æ–¹æ³•1. åŠ›å°½ã

ã¾ãšã¯æ„šç›´ã«å…¨ã¦ã® $\sin i$ ã«å¯¾ã—ã¦ä¸Šã®è©•ä¾¡å¼ã‚’é©ç”¨ã—ã¾ã™ã€‚

$x$ ãŒæœ‰ç†æ•°ï¼ˆç‰¹ã«æ•´æ•°ï¼‰ãªã‚‰ä¸Šä¸‹é™ã¨ã‚‚ã«æœ‰ç†æ•°ã®ç¯„å›²ã§è¨ˆç®—ã§ãã‚‹ãŸã‚ã€å·¨å¤§ãªæ•´æ•°ã•ãˆæ‰±ã†ã“ã¨ãŒã§ãã‚Œã°ã‚ã¨ã¯è¨ˆç®—ã™ã‚‹ã ã‘ã§ã™ã€‚

å·¨å¤§ãªæ•´æ•°ã‚„ãã‚Œã‚’æˆåˆ†ã«æŒã¤æœ‰ç†æ•°ã¯ `num` ã‚¯ãƒ¬ãƒ¼ãƒˆã«ã‚ˆã£ã¦æ‰±ãˆã¾ã™ã€‚

[num \- crates\.io: Rust Package Registry](https://crates.io/crates/num)

:::details å®Ÿè£…
```rust:sin_brute_force/src/main.rs
use num::bigint::{BigInt, Sign};
use num::rational::BigRational;
use num::Signed;
use num::{One, Zero};
use std::result::Result;

const T: [u32; 65] = [
    0, 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,
    0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
    0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x2441453, 0xd8a1e681,
    0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9,
    0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60,
    0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,
    0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
    0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,
    0xeb86d391,
];

fn main() {
    let c = BigRational::from_integer(BigInt::new(Sign::Plus, vec![0, 1])); //=4294967296
    for x in 1..=64 {
        for i in 0.. {
            let (l, r) = approx_range(x, i);
            if l.signum() != r.signum() {
                continue;
            }
            let a = num::abs(&c * &l).floor().to_integer();
            let b = num::abs(&c * &r).floor().to_integer();
            if a == b {
                let t = to_u32(&a).unwrap();
                assert_eq!(T[x as usize], t);
                println!("{} {:x} {}", x, t, i);
                break;
            }
        }
    }
}

fn to_u32(n: &BigInt) -> Result<u32, ()> {
    let (sign, v) = n.to_u32_digits();
    if sign != Sign::Plus || v.len() != 1 {
        Result::Err(())
    } else {
        Result::Ok(v[0])
    }
}

fn approx_range(x: u32, n: u32) -> (BigRational, BigRational) {
    let mut sum = BigRational::zero();
    for i in 0..=n {
        sum += match i % 4 {
            1 => BigRational::new(BigInt::new(Sign::Plus, vec![x]).pow(i), factorial(i)),
            3 => BigRational::new(BigInt::new(Sign::Minus, vec![x]).pow(i), factorial(i)),
            _ => BigRational::zero(),
        };
    }
    let err = num::abs(BigRational::new(
        BigInt::new(Sign::Plus, vec![x]).pow(n + 1),
        factorial(n + 1),
    ));
    (&sum - &err, &sum + &err)
}

fn factorial(n: u32) -> BigInt {
    if n == 0 || n == 1 {
        BigInt::one()
    } else if n > 1 {
        BigInt::new(Sign::Plus, vec![n]) * factorial(n - 1)
    } else {
        panic!();
    }
}

```
:::

[diy\_md5/main\.rs at main Â· roiban1344/diy\_md5](https://github.com/roiban1344/diy_md5/blob/main/sin_brute_force/src/main.rs)

:::details å‡ºåŠ›
```
1 d76aa478 13
2 e8c7b756 17
3 242070db 21
4 c1bdceee 25
5 f57c0faf 28
6 4787c62a 31
7 a8304613 34
8 fd469501 37
9 698098d8 41
10 8b44f7af 43
11 ffff5bb1 46
12 895cd7be 49
13 6b901122 53
14 fd987193 55
15 a679438e 57
16 49b40821 60
17 f61e2562 64
18 c040b340 66
19 265e5a51 68
20 e9b6c7aa 72
21 d62f105d 75
22 2441453 78
23 d8a1e681 80
24 e7d3fbc8 82
25 21e1cde6 86
26 c33707d6 89
27 f4d50d87 92
28 455a14ed 94
29 a9e3e905 96
30 fcefa3f8 101
31 676f02d9 104
32 8d2a4c8a 106
33 fffa3942 109
34 8771f681 111
35 6d9d6122 114
36 fde5380c 115
37 a4beea44 119
38 4bdecfa9 122
39 f6bb4b60 125
40 bebfbc70 126
41 289b7ec6 130
42 eaa127fa 132
43 d4ef3085 135
44 4881d05 137
45 d9d4d039 140
46 e6db99e5 145
47 1fa27cf8 147
48 c4ac5665 149
49 f4292244 152
50 432aff97 154
51 ab9423a7 158
52 fc93a039 161
53 655b59c3 163
54 8f0ccc92 166
55 ffeff47d 168
56 85845dd1 171
57 6fa87e4f 173
58 fe2ce6e0 176
59 a3014314 179
60 4e0811a1 183
61 f7537e82 184
62 bd3af235 186
63 2ad7d2bb 190
64 eb86d391 192
```
:::

å‡ºåŠ›ã®å„è¡Œã¯
```
i T_iã®è¨ˆç®—å€¤ å€¤ãŒç¢ºå®šã™ã‚‹ã®ã«å¿…è¦ãªæœ€å°é …æ•°ï¼ˆä¸Šã®å¼ã®nï¼‰  
```
ã¨ãªã£ã¦ã„ã¾ã™ã€‚

`assert_eq!` ã§RFC1321ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹å€¤ `T` ã¨ã®ä¸€è‡´ã‚’æ¤œè¨¼ã—ã¦ã€æ­£ã—ãè¨ˆç®—ã§ãã¦ã„ã‚‹ã“ã¨ãŒç¢ºã‹ã‚ã‚‰ã‚Œã¾ã—ãŸã€‚

ã—ã‹ã—ã“ã®æ–¹æ³•ã¯è‘—ã—ãã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆã•ã«ã‹ã‘ã¾ã™ã€‚çµæœã«ç¤ºã—ãŸé€šã‚Šã€$i=64$ ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ã€å®Ÿéš›ã« $192!$ ã¨ã„ã†å·¨å¤§ãªå€¤ã‚’è¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚ã“ã®ã¨ãã€$\sin 64$ ã®è¿‘ä¼¼ã«ç”¨ã„ã‚‰ã‚ŒãŸåŒºé–“ã®ä¸Šä¸‹é™å€¤ã¯

$$
\begin{align*}
S_n-W_n &= \frac{3651657157709632429621773107660790167468774167256674373270738569599674653579034218585481015992170214588323933855116913299410112610029504742220078937750554441083303523402000431070075574889112022950255030494439411312602987258791078297807139173049341047292712976990157835013751547718338437807893946114368}{3969080228748870734062672344953331518424707253458286072182412738360339508651264331715423002947493777172551554950501275192830478121245439671569386475282932022860772435425373575751535445841740829756037427703853970095093624941269207059267250157681021055299110269120835245786338418838568031787872314453125},\\
S_n+W_n &= \frac{8033645747959111499935260742681924724949722450998409251413353623870557859092481226822540268075253454840630505025928432680798495364051129427080970493420805669525683461644403784829709103014815311212742560679093383259998533966005777482736141375152977938267990628131907690468131425801523810792538686415552}{8731976503247515614937879158897329340534355957608229358801308024392746919032781529773930606484486309779613420891102805424227051866739967277452650245622450450293699357935821866653377980851829825463282340948478734209205974870792255530387950346898246321658042592065837540729944521444849669933319091796875}.
\end{align*}
$$

ã¨ã„ã†éå‰°ã«å·¨å¤§ãªåˆ†å­åˆ†æ¯ã‚’æŒã¤æœ‰ç†æ•°ã§ã™ã€‚

## æ–¹æ³•2. åŠ æ³•å®šç†ã«ã‚ˆã‚‹å†å¸°

æ±‚ã‚ãŸã„ $\sin$ ã®å¼•æ•°ã¯ $1$ ãƒ©ã‚¸ã‚¢ãƒ³ã®æ•´æ•°å€ã§ã‚ã‚‹ãŸã‚ã€$\cos 1$ ã¨çµ„ã¿åˆã‚ã›ã¦åŠ æ³•å®šç†ã‚’ç¹°ã‚Šè¿”ã—ä½¿ã†ã“ã¨ã§è¨ˆç®—ã§ãã‚‹ã¯ãšã§ã™ã€‚

ãŸã ã—ã€èª¤å·®ã‚’å³å¯†ã«å–ã‚Šæ‰±ã†ãŸã‚ã€å’Œå·®ç©ã‚’å–ã‚‹éš›ã«ã¯ç°¡æ˜“ã‹ã¤é™å®šçš„ãª[åŒºé–“æ¼”ç®—](https://ja.wikipedia.org/wiki/%E5%8C%BA%E9%96%93%E6%BC%94%E7%AE%97)^[[åŒºé–“æ¼”ç®—ã®å®Ÿè£…ã«ã¤ã„ã¦\(1\) \- kashiã®æ—¥è¨˜](http://verifiedby.me/adiary/070)ãªã©ã‚’å‚ç…§ã€‚Rustç”¨ã®ç²¾åº¦ä¿è¨¼ä»˜ãæ•°å€¤è¨ˆç®—ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã„ãŸã„ã¨ã“ã‚ã§ã™ãŒã€ä»Šå›ã¯å®Ÿè£…ã—ã¦ã—ã¾ã„ã¾ã—ãŸã€‚]ã‚’ä½¿ã„ã¾ã™ã€‚

èª¤å·®ã¯æ¼”ç®—ã”ã¨ã«æ‹¡å¤§ã™ã‚‹ãŸã‚ã€åˆæœŸå€¤ã¨ãªã‚‹ $\sin 1, \cos 1$ ã¯ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã«ã‚ˆã‚‹è©•ä¾¡ã§

$$
\begin{align}
\sin 1 &\in \left[ \frac{7761199951101802512}{2^{63}}, \frac{7761199951101802513}{2^{63}} \right],\\
\cos 1 &\in \left[ \frac{4983409179392355912}{2^{63}}, \frac{4983409179392355913}{2^{63}} \right]
\end{align}
$$

ã¨èª¤å·®ç¯„å›²ã‚’ $1/2^{63}$ ã«ã¾ã§ç‹­ã‚ã¦ãŠãã¾ã™ã€‚ã“ã®å€¤ã ã‘ã¯ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚’ä½¿ã£ã¦ï¼ˆç¬¬20é …ã¾ã§ã§å¾—ã‚‰ã‚Œã‚‹ï¼‰è¨ˆç®—ã—ã¦ãŠãã¾ã™ã€‚

:::details å®Ÿè£…
```rust:sin_recursion/src/main.rs
use num::integer;
use std::ops::{Add, Mul, Sub};

//RFC1321è¨˜è¼‰ã®å€¤
const T: [u32; 65] = [
    0, 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,
    0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
    0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x2441453, 0xd8a1e681,
    0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9,
    0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60,
    0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,
    0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
    0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,
    0xeb86d391,
];

const RANGE_MAX: usize = 64;

macro_rules! frac_from_interval {
    [$min:expr, $max:expr] => [
        Frac::new(Interval::new($min, $max))
    ]
}

fn main() {
    let mut sin = vec![Option::<Frac>::None; RANGE_MAX + 1];
    let mut cos = vec![Option::<Frac>::None; RANGE_MAX + 1];
    sin[1] = Some(frac_from_interval![
        7761199951101802512,
        7761199951101802513
    ]);
    cos[1] = Some(frac_from_interval![
        4983409179392355912,
        4983409179392355913
    ]);

    let print_data = |i: i32, frac: &Frac| -> () {
        let t = frac.times_4294967296_to_u32();
        assert_eq!(t, T[i as usize]);
        println!("{0} {1:#x} {2}", i, t, frac.num.max - frac.num.min)
    };

    print_data(1, &sin[1].unwrap());

    for i in 2..=RANGE_MAX {
        let s1 = sin[i / 2].unwrap();
        let c1 = cos[i / 2].unwrap();
        let s2 = sin[(i + 1) / 2].unwrap();
        let c2 = cos[(i + 1) / 2].unwrap();
        sin[i] = Some(s1 * c2 + c1 * s2);
        cos[i] = Some(c1 * c2 - s1 * s2);
        print_data(i as i32, &sin[i].unwrap());
    }
}

//åŒºé–“æ¼”ç®—ã«ç”¨ã„ã‚‹ã€ŒåŒºé–“ã€ã€‚
[derive(Copy, Clone, Debug)]
struct Interval {
    min: i128,
    max: i128,
}

impl Interval {
    fn new(min: i128, max: i128) -> Interval {
        if min < 0 && 0 < max {
            panic!("Cannot contain 0.");
        } else if min > max {
            panic!("min = {} < max = {} is not satisfied.", min, max);
        }
        Interval { min, max }
    }

    fn signum(&self) -> i32 {
        if self.min > 0 && self.max > 0 {
            1
        } else if self.min < 0 && self.max < 0 {
            -1
        } else {
            panic!("Contains 0 {:?}", self);
        }
    }
}

//å’Œå·®ç©ã®æœªå®Ÿè£…ã€‚
impl Add for Interval {
    type Output = Self;
    fn add(self, rhs: Self) -> Self {
        Interval::new(self.min + rhs.min, self.max + rhs.max)
    }
}

impl Sub for Interval {
    type Output = Self;
    fn sub(self, rhs: Self) -> Self {
        Interval::new(self.min - rhs.max, self.max - rhs.min)
    }
}

impl Mul for Interval {
    type Output = Self;
    fn mul(self, rhs: Self) -> Self {
        let a = self.min;
        let b = self.max;
        let c = rhs.min;
        let d = rhs.max;
        let (min, max) = match (self.signum(), rhs.signum()) {
            (1, 1) => (a * c, b * d),
            (1, -1) => (b * c, a * d),
            (-1, 1) => (a * d, b * c),
            (-1, -1) => (b * d, a * c),
            _ => unreachable!(),
        };
        Interval::new(min, max)
    }
}

//2^63ã‚’åˆ†æ¯ã«æŒã¡ã€[-2^63,2^63]ã«å«ã¾ã‚Œã‚‹åŒºé–“ã‚’åˆ†æ¯ã«æŒã¤æœ‰ç†æ•°ã€‚
[derive(Debug, Copy, Clone)]
struct Frac {
    num: Interval, //denom=2^63
}

impl Frac {
    fn new(num: Interval) -> Self {
        if num.min < -(1 << 63) || 1 << 63 < num.max {
            panic!("Out of range")
        }
        Self { num }
    }

    //2^32å€ã®æ•´æ•°éƒ¨åˆ†ã‚’è¿”ã™
    fn times_4294967296_to_u32(&self) -> u32 {
        let min = integer::div_floor(self.num.min.abs(), 1 << 31);
        let max = integer::div_floor(self.num.max.abs(), 1 << 31);
        if min == max {
            min as u32
        } else {
            println!("{:?}", self.num);
            panic!("min={}, max={}", min, max);
        }
    }
}

//å’Œå·®ç©ã®ã¿å®Ÿè£…ã€‚
impl Add for Frac {
    type Output = Self;
    fn add(self, rhs: Self) -> Self {
        Frac::new(self.num + rhs.num)
    }
}

impl Sub for Frac {
    type Output = Self;
    fn sub(self, rhs: Self) -> Self {
        Frac::new(self.num - rhs.num)
    }
}

impl Mul for Frac {
    type Output = Self;
    fn mul(self, rhs: Self) -> Self {
        let num_prod = self.num * rhs.num;
        let floor = integer::div_floor(num_prod.min, 1 << 63);
        let ceil = integer::div_ceil(num_prod.max, 1 << 63);
        frac_from_interval![floor, ceil]
    }
}
```
:::

[diy\_md5/main\.rs at main Â· roiban1344/diy\_md5](https://github.com/roiban1344/diy_md5/blob/main/sin_recursion/src/main.rs)

:::details å‡ºåŠ›
```
1 0xd76aa478 1
2 0xe8c7b756 4
3 0x242070db 9
4 0xc1bdceee 14
5 0xf57c0faf 20
6 0x4787c62a 22
7 0xa8304613 32
8 0xfd469501 40
9 0x698098d8 48
10 0x8b44f7af 54
11 0xffff5bb1 55
12 0x895cd7be 56
13 0x6b901122 73
14 0xfd987193 90
15 0xa679438e 96
16 0x49b40821 98
17 0xf61e2562 110
18 0xc040b340 130
19 0x265e5a51 139
20 0xe9b6c7aa 150
21 0xd62f105d 132
22 0x2441453 114
23 0xd8a1e681 137
24 0xe7d3fbc8 160
25 0x21e1cde6 179
26 0xc33707d6 198
27 0xf4d50d87 205
28 0x455a14ed 208
29 0xa9e3e905 237
30 0xfcefa3f8 272
31 0x676f02d9 257
32 0x8d2a4c8a 244
33 0xfffa3942 257
34 0x8771f681 276
35 0x6d9d6122 319
36 0xfde5380c 368
37 0xa4beea44 346
38 0x4bdecfa9 318
39 0xf6bb4b60 357
40 0xbebfbc70 398
41 0x289b7ec6 386
42 0xeaa127fa 368
43 0xd4ef3085 293
44 0x4881d05 232
45 0xd9d4d039 297
46 0xe6db99e5 378
47 0x1fa27cf8 405
48 0xc4ac5665 430
49 0xf4292244 423
50 0x432aff97 406
51 0xab9423a7 479
52 0xfc93a039 560
53 0x655b59c3 539
54 0x8f0ccc92 514
55 0xffeff47d 511
56 0x85845dd1 514
57 0x6fa87e4f 586
58 0xfe2ce6e0 672
59 0xa3014314 658
60 0x4e0811a1 624
61 0xf7537e82 655
62 0xbd3af235 680
63 0x2ad7d2bb 677
64 0xeb86d391 672
```
:::

å‡ºåŠ›ã®å„è¡Œã¯
```
i T_iã®è¨ˆç®—å€¤ (åŒºé–“ã®ä¸Šé™-ä¸‹é™)*2^63 
```
ã¨ãªã£ã¦ã„ã¾ã™ã€‚

è¨ˆç®—ã®å„æ‰€ã«å‰æãŒå´©ã‚ŒãŸå ´åˆã«å‚™ãˆãŸæ„å›³çš„ãª`panic!`ã‚’å«ã‚“ã§ã„ã¾ã™ãŒã€å¿…è¦ãªç¯„å›²å†…ã§ç„¡äº‹ã«è¨ˆç®—ã‚’çµ‚ãˆã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸã€‚`assert_eq!`ã§RFC1321è¨˜è¼‰ã®å€¤ã¨ä¸€è‡´ã™ã‚‹ã“ã¨ã‚‚ç¢ºã‹ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

ã¡ãªã¿ã«ã‚‚ã£ã¨å…ˆã¾ã§è¨ˆç®—ã‚’é€²ã‚ãŸå ´åˆã€`i=8195`ã§åˆã‚ã¦`panic!`ã—ã¾ã™ã€‚

## æ–¹æ³•3. æµ®å‹•å°æ•°ç‚¹æ•°

æµ®å‹•å°æ•°ç‚¹æ•°ã§ã‚‚è¨ˆç®—ã—ã¦ã¿ã¾ã™ã€‚`f32` ã§è¨ˆç®—ã—ãŸå ´åˆã¯ç²¾åº¦ãŒè¶³ã‚ŠãšçµæœãŒä¸€è‡´ã—ã¾ã›ã‚“ãŒã€`f64` ã¯å…¨ã¦ã®ã‚±ãƒ¼ã‚¹ã§RFC1321è¨˜è¼‰ã®å€¤ã¨ä¸€è‡´ã—ã¾ã™ã€‚

`f32` ã¨ `f64` ã‚’çµ±ä¸€çš„ã«æ‰±ã†ãŸã‚ã€`num-traits` ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚

[num\-traits \- crates\.io: Rust Package Registry](https://crates.io/crates/num-traits)

:::details å®Ÿè£…
```rust:sin_float/src/main.rs
use num_traits::{Float, FromPrimitive};

//RFC1321è¨˜è¼‰ã®å€¤
const T: [u32; 65] = [
    0, 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,
    0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
    0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x2441453, 0xd8a1e681,
    0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9,
    0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60,
    0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,
    0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
    0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,
    0xeb86d391,
];

fn main() {
    for i in 1..=64 {
        let t_f32 = t_float::<f32>(i);
        let t_f64 = t_float::<f64>(i);
        let t = T[i as usize] as i64;
        let diff_f32 = (t_f32 - t).abs();
        let diff_f64 = (t_f64 - t).abs();
        assert_eq!(t, t_f64);
        println!("{:>2} {:08x} {:>3} {}", i, t, diff_f32, diff_f64);
    }
}

//floor(4294967296*abs(sin(i)))ã‚’f32, f64ã§è¨ˆç®—
fn t_float<T: Float + FromPrimitive>(i: i64) -> i64 {
    let sin = T::from_i64(i).unwrap().sin();
    let x = sin.abs() * T::from_i64(4294967296_i64).unwrap();
    T::to_i64(&x.floor()).unwrap()
}

```
:::

[diy\_md5/main\.rs at main Â· roiban1344/diy\_md5](https://github.com/roiban1344/diy_md5/blob/main/sin_float/src/main.rs)

:::details å‡ºåŠ›
```
 1 d76aa478 120 0
 2 e8c7b756  86 0
 3 242070db  27 0
 4 c1bdceee  18 0
 5 f57c0faf  81 0
 6 4787c62a  42 0
 7 a8304613  19 0
 8 fd469501   1 0
 9 698098d8  40 0
10 8b44f7af  81 0
11 ffff5bb1  79 0
12 895cd7be  66 0
13 6b901122  34 0
14 fd987193 109 0
15 a679438e 114 0
16 49b40821  33 0
17 f61e2562  98 0
18 c040b340  64 0
19 265e5a51  17 0
20 e9b6c7aa  86 0
21 d62f105d  93 0
22 02441453   1 0
23 d8a1e681 127 0
24 e7d3fbc8  56 0
25 21e1cde6  26 0
26 c33707d6  42 0
27 f4d50d87 121 0
28 455a14ed  19 0
29 a9e3e905   5 0
30 fcefa3f8   8 0
31 676f02d9  39 0
32 8d2a4c8a 118 0
33 fffa3942  66 0
34 8771f681 127 0
35 6d9d6122  34 0
36 fde5380c  12 0
37 a4beea44  68 0
38 4bdecfa9  41 0
39 f6bb4b60  96 0
40 bebfbc70 112 0
41 289b7ec6   6 0
42 eaa127fa   6 0
43 d4ef3085 123 0
44 04881d05   3 0
45 d9d4d039  57 0
46 e6db99e5  27 0
47 1fa27cf8   8 0
48 c4ac5665 101 0
49 f4292244  68 0
50 432aff97  23 0
51 ab9423a7  89 0
52 fc93a039  57 0
53 655b59c3  61 0
54 8f0ccc92 110 0
55 ffeff47d 125 0
56 85845dd1  47 0
57 6fa87e4f  49 0
58 fe2ce6e0  32 0
59 a3014314  20 0
60 4e0811a1  33 0
61 f7537e82 126 0
62 bd3af235  53 0
63 2ad7d2bb   5 0
64 eb86d391 111 0
```
:::

å„è¡Œã®å€¤ã¯ã€
```
i T[i] (f32ã§è¨ˆç®—ã—ãŸå ´åˆã®èª¤å·®) (f64ã§è¨ˆç®—ã—ãŸå ´åˆã®èª¤å·®)
```
ã§ã™ã€‚å†å¸°ã§å®Ÿè£…ã—ãŸå ´åˆã«è¨ˆç®—å¯èƒ½ãª $1 \leq i\leq 8194$ ã®å…¨ã¦ã®å ´åˆã§ä¸€è‡´ã™ã‚‹ã“ã¨ã‚‚ç¢ºã‹ã‚ã‚‰ã‚Œã¾ã™ã€‚

ã¨ã¯ã„ãˆã€ã“ã‚Œã¯ã€Œé‹ãŒè‰¯ã‹ã£ãŸã€ã¨æ‰ãˆã‚‹ã¹ãã‚‚ã®ã§ã—ã‚‡ã†ã€‚$\lfloor 4294967296 |\sin(i)| \rfloor$ ã¨ã„ã†å³å¯†ãªæ•´æ•°å€¤ã‚’å¿…è¦ã¨ã™ã‚‹å ´åˆã«ã¯ä¿¡é ¼ã§ããªã„å€¤ã§ã™ã€‚

# ã¾ã¨ã‚
æœ¬è¨˜äº‹ã§ã¯RFC1321ã«æ²¿ã£ã¦Rustã§MD5ãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã¾ã—ãŸã€‚

ãªã‹ãªã‹æ…£ã‚Œãªã„æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã«ä»£è¡¨ã•ã‚Œã‚‹ã€ŒRustç‰¹æœ‰ã®èº“ãã©ã“ã‚ã€ã¯ã‚ã¾ã‚Šãªã‹ã£ãŸä¸€æ–¹ã§ã€ãƒã‚¤ãƒˆé †ã‚’æ‰±ã†ãŸã‚ã®å¤–éƒ¨ã‚¯ãƒ¬ãƒ¼ãƒˆã®å°å…¥ãŒå®Ÿã«å¿«é©ã ã£ãŸã‚Šã€æ–‡å­—åˆ—ã¨ãƒã‚¤ãƒˆã®åˆ—ãŒå³æ ¼ã«åŒºåˆ¥ã•ã‚Œã¦ã„ãŸã‚Šã™ã‚‹ç‚¹ã«Rustã‚‰ã—ã•ã‚’å‘³ã‚ã†ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«æ€ã„ã¾ã™ã€‚

æœ¬ç­‹ã‹ã‚‰ã¯é€¸ã‚ŒãŸå†…å®¹ã§ã™ãŒã€$T_i$ ã®å€¤ã¨ã„ã†æ•°å­¦çš„ã«å³å¯†ãªçµæœã‚’ã“ã†ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§å¾—ã‚‰ã‚Œã‚‹ã®ã¯ä½•åº¦çµŒé¨“ã—ã¦ã‚‚è‰¯ã„ã‚‚ã®ã§ã™ã€‚

[SHA-1](https://en.wikipedia.org/wiki/SHA-1)ã‚„[SHA-2](https://en.wikipedia.org/wiki/SHA-2)ã‚‚ã»ã¼åŒæ§˜ã®æ‰‹é †ã«åŸºã¥ããƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã™ã€‚ã„ãšã‚Œå®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

ã¾ãŸã€ä»Šå›ã¯å«ã‚ã‚‰ã‚Œãªã‹ã£ãŸã®ãŒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã§ã™ã€‚ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆã®æ–¹æ³•ãªã©ã‚’çŸ¥ã£ãŸã†ãˆã§å–ã‚Šçµ„ã‚€ã“ã¨ã¯ä»Šå¾Œã®èª²é¡Œã§ã™ã€‚